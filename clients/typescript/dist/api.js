"use strict";
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Sherlock
 * The Data Science Platform's source-of-truth service
 *
 * OpenAPI spec version: development
 * Contact: dsp-devops@broadinstitute.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiscApi = exports.MiscApiFactory = exports.MiscApiFp = exports.MiscApiFetchParamCreator = exports.EnvironmentsApi = exports.EnvironmentsApiFactory = exports.EnvironmentsApiFp = exports.EnvironmentsApiFetchParamCreator = exports.ClustersApi = exports.ClustersApiFactory = exports.ClustersApiFp = exports.ClustersApiFetchParamCreator = exports.ChartsApi = exports.ChartsApiFactory = exports.ChartsApiFp = exports.ChartsApiFetchParamCreator = exports.ChartVersionsApi = exports.ChartVersionsApiFactory = exports.ChartVersionsApiFp = exports.ChartVersionsApiFetchParamCreator = exports.ChartReleasesApi = exports.ChartReleasesApiFactory = exports.ChartReleasesApiFp = exports.ChartReleasesApiFetchParamCreator = exports.ChartDeployRecordsApi = exports.ChartDeployRecordsApiFactory = exports.ChartDeployRecordsApiFp = exports.ChartDeployRecordsApiFetchParamCreator = exports.AppVersionsApi = exports.AppVersionsApiFactory = exports.AppVersionsApiFp = exports.AppVersionsApiFetchParamCreator = exports.V2controllersEditableChartRelease = exports.V2controllersCreatableCluster = exports.V2controllersCreatableChartRelease = exports.V2controllersCluster = exports.V2controllersChartRelease = exports.RequiredError = exports.BaseAPI = exports.COLLECTION_FORMATS = void 0;
const url = require("url");
const isomorphicFetch = require("isomorphic-fetch");
const BASE_PATH = "/".replace(/\/+$/, "");
/**
 *
 * @export
 */
exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};
/**
 *
 * @export
 * @class BaseAPI
 */
class BaseAPI {
    constructor(configuration, basePath = BASE_PATH, fetch = isomorphicFetch) {
        this.basePath = basePath;
        this.fetch = fetch;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
exports.BaseAPI = BaseAPI;
;
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
class RequiredError extends Error {
    constructor(field, msg) {
        super(msg);
        this.field = field;
    }
}
exports.RequiredError = RequiredError;
/**
 * @export
 * @namespace V2controllersChartRelease
 */
var V2controllersChartRelease;
(function (V2controllersChartRelease) {
    /**
     * @export
     * @enum {string}
     */
    let TargetAppVersionUseEnum;
    (function (TargetAppVersionUseEnum) {
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Branch"] = 'branch'] = "Branch";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Commit"] = 'commit'] = "Commit";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetAppVersionUseEnum = V2controllersChartRelease.TargetAppVersionUseEnum || (V2controllersChartRelease.TargetAppVersionUseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TargetChartVersionUseEnum;
    (function (TargetChartVersionUseEnum) {
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Latest"] = 'latest'] = "Latest";
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetChartVersionUseEnum = V2controllersChartRelease.TargetChartVersionUseEnum || (V2controllersChartRelease.TargetChartVersionUseEnum = {}));
})(V2controllersChartRelease = exports.V2controllersChartRelease || (exports.V2controllersChartRelease = {}));
/**
 * @export
 * @namespace V2controllersCluster
 */
var V2controllersCluster;
(function (V2controllersCluster) {
    /**
     * @export
     * @enum {string}
     */
    let ProviderEnum;
    (function (ProviderEnum) {
        ProviderEnum[ProviderEnum["Google"] = 'google'] = "Google";
        ProviderEnum[ProviderEnum["Azure"] = 'azure'] = "Azure";
    })(ProviderEnum = V2controllersCluster.ProviderEnum || (V2controllersCluster.ProviderEnum = {}));
})(V2controllersCluster = exports.V2controllersCluster || (exports.V2controllersCluster = {}));
/**
 * @export
 * @namespace V2controllersCreatableChartRelease
 */
var V2controllersCreatableChartRelease;
(function (V2controllersCreatableChartRelease) {
    /**
     * @export
     * @enum {string}
     */
    let TargetAppVersionUseEnum;
    (function (TargetAppVersionUseEnum) {
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Branch"] = 'branch'] = "Branch";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Commit"] = 'commit'] = "Commit";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetAppVersionUseEnum = V2controllersCreatableChartRelease.TargetAppVersionUseEnum || (V2controllersCreatableChartRelease.TargetAppVersionUseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TargetChartVersionUseEnum;
    (function (TargetChartVersionUseEnum) {
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Latest"] = 'latest'] = "Latest";
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetChartVersionUseEnum = V2controllersCreatableChartRelease.TargetChartVersionUseEnum || (V2controllersCreatableChartRelease.TargetChartVersionUseEnum = {}));
})(V2controllersCreatableChartRelease = exports.V2controllersCreatableChartRelease || (exports.V2controllersCreatableChartRelease = {}));
/**
 * @export
 * @namespace V2controllersCreatableCluster
 */
var V2controllersCreatableCluster;
(function (V2controllersCreatableCluster) {
    /**
     * @export
     * @enum {string}
     */
    let ProviderEnum;
    (function (ProviderEnum) {
        ProviderEnum[ProviderEnum["Google"] = 'google'] = "Google";
        ProviderEnum[ProviderEnum["Azure"] = 'azure'] = "Azure";
    })(ProviderEnum = V2controllersCreatableCluster.ProviderEnum || (V2controllersCreatableCluster.ProviderEnum = {}));
})(V2controllersCreatableCluster = exports.V2controllersCreatableCluster || (exports.V2controllersCreatableCluster = {}));
/**
 * @export
 * @namespace V2controllersEditableChartRelease
 */
var V2controllersEditableChartRelease;
(function (V2controllersEditableChartRelease) {
    /**
     * @export
     * @enum {string}
     */
    let TargetAppVersionUseEnum;
    (function (TargetAppVersionUseEnum) {
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Branch"] = 'branch'] = "Branch";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Commit"] = 'commit'] = "Commit";
        TargetAppVersionUseEnum[TargetAppVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetAppVersionUseEnum = V2controllersEditableChartRelease.TargetAppVersionUseEnum || (V2controllersEditableChartRelease.TargetAppVersionUseEnum = {}));
    /**
     * @export
     * @enum {string}
     */
    let TargetChartVersionUseEnum;
    (function (TargetChartVersionUseEnum) {
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Latest"] = 'latest'] = "Latest";
        TargetChartVersionUseEnum[TargetChartVersionUseEnum["Exact"] = 'exact'] = "Exact";
    })(TargetChartVersionUseEnum = V2controllersEditableChartRelease.TargetChartVersionUseEnum || (V2controllersEditableChartRelease.TargetChartVersionUseEnum = {}));
})(V2controllersEditableChartRelease = exports.V2controllersEditableChartRelease || (exports.V2controllersEditableChartRelease = {}));
/**
 * AppVersionsApi - fetch parameter creator
 * @export
 */
const AppVersionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt]
         * @param {string} [gitBranch]
         * @param {string} [gitCommit]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options = {}) {
            const localVarPath = `/api/v2/app-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }
            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (gitBranch !== undefined) {
                localVarQueryParameter['gitBranch'] = gitBranch;
            }
            if (gitCommit !== undefined) {
                localVarQueryParameter['gitCommit'] = gitCommit;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2AppVersionsPost.');
            }
            const localVarPath = `/api/v2/app-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableAppVersion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2AppVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/app-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsAppVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/app-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.AppVersionsApiFetchParamCreator = AppVersionsApiFetchParamCreator;
/**
 * AppVersionsApi - functional programming interface
 * @export
 */
const AppVersionsApiFp = function (configuration) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt]
         * @param {string} [gitBranch]
         * @param {string} [gitCommit]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.AppVersionsApiFetchParamCreator)(configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body, options) {
            const localVarFetchArgs = (0, exports.AppVersionsApiFetchParamCreator)(configuration).apiV2AppVersionsPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.AppVersionsApiFetchParamCreator)(configuration).apiV2AppVersionsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.AppVersionsApiFetchParamCreator)(configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.AppVersionsApiFp = AppVersionsApiFp;
/**
 * AppVersionsApi - factory interface
 * @export
 */
const AppVersionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt]
         * @param {string} [gitBranch]
         * @param {string} [gitCommit]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options) {
            return (0, exports.AppVersionsApiFp)(configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body, options) {
            return (0, exports.AppVersionsApiFp)(configuration).apiV2AppVersionsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector, options) {
            return (0, exports.AppVersionsApiFp)(configuration).apiV2AppVersionsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector, options) {
            return (0, exports.AppVersionsApiFp)(configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.AppVersionsApiFactory = AppVersionsApiFactory;
/**
 * AppVersionsApi - object-oriented interface
 * @export
 * @class AppVersionsApi
 * @extends {BaseAPI}
 */
class AppVersionsApi extends BaseAPI {
    /**
     * List existing AppVersion entries, ordered by most recently updated.
     * @summary List AppVersion entries
     * @param {string} [appVersion] Required when creating
     * @param {string} [chart] Required when creating
     * @param {string} [createdAt]
     * @param {string} [gitBranch]
     * @param {string} [gitCommit]
     * @param {number} [id]
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options) {
        return (0, exports.AppVersionsApiFp)(this.configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new AppVersion entry. Note that fields are immutable after creation.
     * @summary Create a new AppVersion entry
     * @param {V2controllersCreatableAppVersion} body The AppVersion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    apiV2AppVersionsPost(body, options) {
        return (0, exports.AppVersionsApiFp)(this.configuration).apiV2AppVersionsPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
     * @summary Get a AppVersion entry
     * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    apiV2AppVersionsSelectorGet(selector, options) {
        return (0, exports.AppVersionsApiFp)(this.configuration).apiV2AppVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
     * @summary List AppVersion selectors
     * @param {string} selector The selector of the AppVersion to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    apiV2SelectorsAppVersionsSelectorGet(selector, options) {
        return (0, exports.AppVersionsApiFp)(this.configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.AppVersionsApi = AppVersionsApi;
/**
 * ChartDeployRecordsApi - fetch parameter creator
 * @export
 */
const ChartDeployRecordsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt]
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options = {}) {
            const localVarPath = `/api/v2/chart-deploy-records`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (chartRelease !== undefined) {
                localVarQueryParameter['chartRelease'] = chartRelease;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (exactAppVersion !== undefined) {
                localVarQueryParameter['exactAppVersion'] = exactAppVersion;
            }
            if (exactChartVersion !== undefined) {
                localVarQueryParameter['exactChartVersion'] = exactChartVersion;
            }
            if (helmfileRef !== undefined) {
                localVarQueryParameter['helmfileRef'] = helmfileRef;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartDeployRecordsPost.');
            }
            const localVarPath = `/api/v2/chart-deploy-records`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableChartDeployRecord" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartDeployRecordsSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-deploy-records/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsChartDeployRecordsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-deploy-records/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChartDeployRecordsApiFetchParamCreator = ChartDeployRecordsApiFetchParamCreator;
/**
 * ChartDeployRecordsApi - functional programming interface
 * @export
 */
const ChartDeployRecordsApiFp = function (configuration) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt]
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.ChartDeployRecordsApiFetchParamCreator)(configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body, options) {
            const localVarFetchArgs = (0, exports.ChartDeployRecordsApiFetchParamCreator)(configuration).apiV2ChartDeployRecordsPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartDeployRecordsApiFetchParamCreator)(configuration).apiV2ChartDeployRecordsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartDeployRecordsApiFetchParamCreator)(configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ChartDeployRecordsApiFp = ChartDeployRecordsApiFp;
/**
 * ChartDeployRecordsApi - factory interface
 * @export
 */
const ChartDeployRecordsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt]
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options) {
            return (0, exports.ChartDeployRecordsApiFp)(configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body, options) {
            return (0, exports.ChartDeployRecordsApiFp)(configuration).apiV2ChartDeployRecordsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector, options) {
            return (0, exports.ChartDeployRecordsApiFp)(configuration).apiV2ChartDeployRecordsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector, options) {
            return (0, exports.ChartDeployRecordsApiFp)(configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.ChartDeployRecordsApiFactory = ChartDeployRecordsApiFactory;
/**
 * ChartDeployRecordsApi - object-oriented interface
 * @export
 * @class ChartDeployRecordsApi
 * @extends {BaseAPI}
 */
class ChartDeployRecordsApi extends BaseAPI {
    /**
     * List existing ChartDeployRecord entries, ordered by most recently updated.
     * @summary List ChartDeployRecord entries
     * @param {string} [chartRelease] Required when creating
     * @param {string} [createdAt]
     * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
     * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
     * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
     * @param {number} [id]
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options) {
        return (0, exports.ChartDeployRecordsApiFp)(this.configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
     * @summary Create a new ChartDeployRecord entry
     * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    apiV2ChartDeployRecordsPost(body, options) {
        return (0, exports.ChartDeployRecordsApiFp)(this.configuration).apiV2ChartDeployRecordsPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
     * @summary Get a ChartDeployRecord entry
     * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    apiV2ChartDeployRecordsSelectorGet(selector, options) {
        return (0, exports.ChartDeployRecordsApiFp)(this.configuration).apiV2ChartDeployRecordsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
     * @summary List ChartDeployRecord selectors
     * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    apiV2SelectorsChartDeployRecordsSelectorGet(selector, options) {
        return (0, exports.ChartDeployRecordsApiFp)(this.configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.ChartDeployRecordsApi = ChartDeployRecordsApi;
/**
 * ChartReleasesApi - fetch parameter creator
 * @export
 */
const ChartReleasesApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt]
         * @param {string} [currentAppVersionExact]
         * @param {string} [currentChartVersionExact]
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef]
         * @param {number} [id]
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit]
         * @param {string} [targetAppVersionExact]
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact]
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options = {}) {
            const localVarPath = `/api/v2/chart-releases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }
            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (currentAppVersionExact !== undefined) {
                localVarQueryParameter['currentAppVersionExact'] = currentAppVersionExact;
            }
            if (currentChartVersionExact !== undefined) {
                localVarQueryParameter['currentChartVersionExact'] = currentChartVersionExact;
            }
            if (destinationType !== undefined) {
                localVarQueryParameter['destinationType'] = destinationType;
            }
            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }
            if (helmfileRef !== undefined) {
                localVarQueryParameter['helmfileRef'] = helmfileRef;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }
            if (targetAppVersionBranch !== undefined) {
                localVarQueryParameter['targetAppVersionBranch'] = targetAppVersionBranch;
            }
            if (targetAppVersionCommit !== undefined) {
                localVarQueryParameter['targetAppVersionCommit'] = targetAppVersionCommit;
            }
            if (targetAppVersionExact !== undefined) {
                localVarQueryParameter['targetAppVersionExact'] = targetAppVersionExact;
            }
            if (targetAppVersionUse !== undefined) {
                localVarQueryParameter['targetAppVersionUse'] = targetAppVersionUse;
            }
            if (targetChartVersionExact !== undefined) {
                localVarQueryParameter['targetChartVersionExact'] = targetChartVersionExact;
            }
            if (targetChartVersionUse !== undefined) {
                localVarQueryParameter['targetChartVersionUse'] = targetChartVersionUse;
            }
            if (thelmaMode !== undefined) {
                localVarQueryParameter['thelmaMode'] = thelmaMode;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartReleasesPost.');
            }
            const localVarPath = `/api/v2/chart-releases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableChartRelease" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorDelete.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body, selector, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartReleasesSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorPatch.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersEditableChartRelease" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsChartReleasesSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChartReleasesApiFetchParamCreator = ChartReleasesApiFetchParamCreator;
/**
 * ChartReleasesApi - functional programming interface
 * @export
 */
const ChartReleasesApiFp = function (configuration) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt]
         * @param {string} [currentAppVersionExact]
         * @param {string} [currentChartVersionExact]
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef]
         * @param {number} [id]
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit]
         * @param {string} [targetAppVersionExact]
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact]
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2ChartReleasesPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2ChartReleasesSelectorDelete(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2ChartReleasesSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body, selector, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2ChartReleasesSelectorPatch(body, selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartReleasesApiFetchParamCreator)(configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ChartReleasesApiFp = ChartReleasesApiFp;
/**
 * ChartReleasesApi - factory interface
 * @export
 */
const ChartReleasesApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt]
         * @param {string} [currentAppVersionExact]
         * @param {string} [currentChartVersionExact]
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef]
         * @param {number} [id]
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit]
         * @param {string} [targetAppVersionExact]
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact]
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2ChartReleasesPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2ChartReleasesSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2ChartReleasesSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body, selector, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2ChartReleasesSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector, options) {
            return (0, exports.ChartReleasesApiFp)(configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.ChartReleasesApiFactory = ChartReleasesApiFactory;
/**
 * ChartReleasesApi - object-oriented interface
 * @export
 * @class ChartReleasesApi
 * @extends {BaseAPI}
 */
class ChartReleasesApi extends BaseAPI {
    /**
     * List existing ChartRelease entries, ordered by most recently updated.
     * @summary List ChartRelease entries
     * @param {string} [chart] Required when creating
     * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
     * @param {string} [createdAt]
     * @param {string} [currentAppVersionExact]
     * @param {string} [currentChartVersionExact]
     * @param {string} [destinationType] Calculated field
     * @param {string} [environment] Either this or cluster must be provided.
     * @param {string} [helmfileRef]
     * @param {number} [id]
     * @param {string} [name] When creating, will be calculated if left empty
     * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
     * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
     * @param {string} [targetAppVersionCommit]
     * @param {string} [targetAppVersionExact]
     * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
     * @param {string} [targetChartVersionExact]
     * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
     * @param {string} [thelmaMode]
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new ChartRelease entry
     * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2ChartReleasesPost(body, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2ChartReleasesPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
     * @summary Delete a ChartRelease entry
     * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2ChartReleasesSelectorDelete(selector, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2ChartReleasesSelectorDelete(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
     * @summary Get a ChartRelease entry
     * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2ChartReleasesSelectorGet(selector, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2ChartReleasesSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a ChartRelease entry
     * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
     * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2ChartReleasesSelectorPatch(body, selector, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2ChartReleasesSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
     * @summary List ChartRelease selectors
     * @param {string} selector The selector of the ChartRelease to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    apiV2SelectorsChartReleasesSelectorGet(selector, options) {
        return (0, exports.ChartReleasesApiFp)(this.configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.ChartReleasesApi = ChartReleasesApi;
/**
 * ChartVersionsApi - fetch parameter creator
 * @export
 */
const ChartVersionsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options = {}) {
            const localVarPath = `/api/v2/chart-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }
            if (chartVersion !== undefined) {
                localVarQueryParameter['chartVersion'] = chartVersion;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartVersionsPost.');
            }
            const localVarPath = `/api/v2/chart-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableChartVersion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsChartVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChartVersionsApiFetchParamCreator = ChartVersionsApiFetchParamCreator;
/**
 * ChartVersionsApi - functional programming interface
 * @export
 */
const ChartVersionsApiFp = function (configuration) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.ChartVersionsApiFetchParamCreator)(configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body, options) {
            const localVarFetchArgs = (0, exports.ChartVersionsApiFetchParamCreator)(configuration).apiV2ChartVersionsPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartVersionsApiFetchParamCreator)(configuration).apiV2ChartVersionsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartVersionsApiFetchParamCreator)(configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ChartVersionsApiFp = ChartVersionsApiFp;
/**
 * ChartVersionsApi - factory interface
 * @export
 */
const ChartVersionsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options) {
            return (0, exports.ChartVersionsApiFp)(configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body, options) {
            return (0, exports.ChartVersionsApiFp)(configuration).apiV2ChartVersionsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector, options) {
            return (0, exports.ChartVersionsApiFp)(configuration).apiV2ChartVersionsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector, options) {
            return (0, exports.ChartVersionsApiFp)(configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.ChartVersionsApiFactory = ChartVersionsApiFactory;
/**
 * ChartVersionsApi - object-oriented interface
 * @export
 * @class ChartVersionsApi
 * @extends {BaseAPI}
 */
class ChartVersionsApi extends BaseAPI {
    /**
     * List existing ChartVersion entries, ordered by most recently updated.
     * @summary List ChartVersion entries
     * @param {string} [chart] Required when creating
     * @param {string} [chartVersion] Required when creating
     * @param {string} [createdAt]
     * @param {number} [id]
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options) {
        return (0, exports.ChartVersionsApiFp)(this.configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new ChartVersion entry. Note that fields are immutable after creation.
     * @summary Create a new ChartVersion entry
     * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    apiV2ChartVersionsPost(body, options) {
        return (0, exports.ChartVersionsApiFp)(this.configuration).apiV2ChartVersionsPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
     * @summary Get a ChartVersion entry
     * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    apiV2ChartVersionsSelectorGet(selector, options) {
        return (0, exports.ChartVersionsApiFp)(this.configuration).apiV2ChartVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
     * @summary List ChartVersion selectors
     * @param {string} selector The selector of the ChartVersion to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    apiV2SelectorsChartVersionsSelectorGet(selector, options) {
        return (0, exports.ChartVersionsApiFp)(this.configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.ChartVersionsApi = ChartVersionsApi;
/**
 * ChartsApi - fetch parameter creator
 * @export
 */
const ChartsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch]
         * @param {string} [appImageGitRepo]
         * @param {string} [chartRepo]
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options = {}) {
            const localVarPath = `/api/v2/charts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (appImageGitMainBranch !== undefined) {
                localVarQueryParameter['appImageGitMainBranch'] = appImageGitMainBranch;
            }
            if (appImageGitRepo !== undefined) {
                localVarQueryParameter['appImageGitRepo'] = appImageGitRepo;
            }
            if (chartRepo !== undefined) {
                localVarQueryParameter['chartRepo'] = chartRepo;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartsPost.');
            }
            const localVarPath = `/api/v2/charts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableChart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartsSelectorDelete.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartsSelectorGet.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body, selector, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ChartsSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ChartsSelectorPatch.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersEditableChart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsChartsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ChartsApiFetchParamCreator = ChartsApiFetchParamCreator;
/**
 * ChartsApi - functional programming interface
 * @export
 */
const ChartsApiFp = function (configuration) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch]
         * @param {string} [appImageGitRepo]
         * @param {string} [chartRepo]
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2ChartsPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2ChartsSelectorDelete(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2ChartsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body, selector, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2ChartsSelectorPatch(body, selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ChartsApiFetchParamCreator)(configuration).apiV2SelectorsChartsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ChartsApiFp = ChartsApiFp;
/**
 * ChartsApi - factory interface
 * @export
 */
const ChartsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch]
         * @param {string} [appImageGitRepo]
         * @param {string} [chartRepo]
         * @param {string} [createdAt]
         * @param {number} [id]
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2ChartsPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2ChartsSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2ChartsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body, selector, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2ChartsSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector, options) {
            return (0, exports.ChartsApiFp)(configuration).apiV2SelectorsChartsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.ChartsApiFactory = ChartsApiFactory;
/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
class ChartsApi extends BaseAPI {
    /**
     * List existing Chart entries, ordered by most recently updated.
     * @summary List Chart entries
     * @param {string} [appImageGitMainBranch]
     * @param {string} [appImageGitRepo]
     * @param {string} [chartRepo]
     * @param {string} [createdAt]
     * @param {number} [id]
     * @param {string} [name] Required when creating
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new Chart entry
     * @param {V2controllersCreatableChart} body The Chart to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2ChartsPost(body, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2ChartsPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Chart entry
     * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2ChartsSelectorDelete(selector, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2ChartsSelectorDelete(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Chart entry
     * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2ChartsSelectorGet(selector, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2ChartsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Chart entry
     * @param {V2controllersEditableChart} body The edits to make to the Chart
     * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2ChartsSelectorPatch(body, selector, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2ChartsSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given Chart selector and provide any other selectors that would match the same Chart.
     * @summary List Chart selectors
     * @param {string} selector The selector of the Chart to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    apiV2SelectorsChartsSelectorGet(selector, options) {
        return (0, exports.ChartsApiFp)(this.configuration).apiV2SelectorsChartsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.ChartsApi = ChartsApi;
/**
 * ClustersApi - fetch parameter creator
 * @export
 */
const ClustersApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt]
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id]
         * @param {string} [provider]
         * @param {boolean} [requiresSuitability]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options = {}) {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name', 'Required parameter name was null or undefined when calling apiV2ClustersGet.');
            }
            const localVarPath = `/api/v2/clusters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (azureSubscription !== undefined) {
                localVarQueryParameter['azureSubscription'] = azureSubscription;
            }
            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (googleProject !== undefined) {
                localVarQueryParameter['googleProject'] = googleProject;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }
            if (requiresSuitability !== undefined) {
                localVarQueryParameter['requiresSuitability'] = requiresSuitability;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ClustersPost.');
            }
            const localVarPath = `/api/v2/clusters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableCluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ClustersSelectorDelete.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ClustersSelectorGet.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body, selector, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2ClustersSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2ClustersSelectorPatch.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersEditableCluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsClustersSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.ClustersApiFetchParamCreator = ClustersApiFetchParamCreator;
/**
 * ClustersApi - functional programming interface
 * @export
 */
const ClustersApiFp = function (configuration) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt]
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id]
         * @param {string} [provider]
         * @param {boolean} [requiresSuitability]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2ClustersPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2ClustersSelectorDelete(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2ClustersSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body, selector, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2ClustersSelectorPatch(body, selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.ClustersApiFetchParamCreator)(configuration).apiV2SelectorsClustersSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.ClustersApiFp = ClustersApiFp;
/**
 * ClustersApi - factory interface
 * @export
 */
const ClustersApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt]
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id]
         * @param {string} [provider]
         * @param {boolean} [requiresSuitability]
         * @param {string} [updatedAt]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2ClustersPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2ClustersSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2ClustersSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body, selector, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2ClustersSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector, options) {
            return (0, exports.ClustersApiFp)(configuration).apiV2SelectorsClustersSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.ClustersApiFactory = ClustersApiFactory;
/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
class ClustersApi extends BaseAPI {
    /**
     * List existing Cluster entries, ordered by most recently updated.
     * @summary List Cluster entries
     * @param {string} name Required when creating
     * @param {string} [address] Required when creating
     * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
     * @param {string} [base] Required when creating
     * @param {string} [createdAt]
     * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
     * @param {number} [id]
     * @param {string} [provider]
     * @param {boolean} [requiresSuitability]
     * @param {string} [updatedAt]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new Cluster entry
     * @param {V2controllersCreatableCluster} body The Cluster to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2ClustersPost(body, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2ClustersPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Cluster entry
     * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2ClustersSelectorDelete(selector, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2ClustersSelectorDelete(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Cluster entry
     * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2ClustersSelectorGet(selector, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2ClustersSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Cluster entry
     * @param {V2controllersEditableCluster} body The edits to make to the Cluster
     * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2ClustersSelectorPatch(body, selector, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2ClustersSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
     * @summary List Cluster selectors
     * @param {string} selector The selector of the Cluster to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    apiV2SelectorsClustersSelectorGet(selector, options) {
        return (0, exports.ClustersApiFp)(this.configuration).apiV2SelectorsClustersSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.ClustersApi = ClustersApi;
/**
 * EnvironmentsApi - fetch parameter creator
 * @export
 */
const EnvironmentsApiFetchParamCreator = function (configuration) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt]
         * @param {string} [defaultCluster]
         * @param {string} [defaultNamespace]
         * @param {number} [id]
         * @param {string} [lifecycle]
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability]
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt]
         * @param {string} [valuesName]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options = {}) {
            const localVarPath = `/api/v2/environments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }
            if (chartReleasesFromTemplate !== undefined) {
                localVarQueryParameter['chartReleasesFromTemplate'] = chartReleasesFromTemplate;
            }
            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }
            if (defaultCluster !== undefined) {
                localVarQueryParameter['defaultCluster'] = defaultCluster;
            }
            if (defaultNamespace !== undefined) {
                localVarQueryParameter['defaultNamespace'] = defaultNamespace;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (lifecycle !== undefined) {
                localVarQueryParameter['lifecycle'] = lifecycle;
            }
            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }
            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }
            if (requiresSuitability !== undefined) {
                localVarQueryParameter['requiresSuitability'] = requiresSuitability;
            }
            if (templateEnvironment !== undefined) {
                localVarQueryParameter['templateEnvironment'] = templateEnvironment;
            }
            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }
            if (valuesName !== undefined) {
                localVarQueryParameter['valuesName'] = valuesName;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2EnvironmentsPost.');
            }
            const localVarPath = `/api/v2/environments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersCreatableEnvironment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorDelete.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorGet.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body, selector, options = {}) {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body', 'Required parameter body was null or undefined when calling apiV2EnvironmentsSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorPatch.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = ("V2controllersEditableEnvironment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : (body || "");
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector, options = {}) {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector', 'Required parameter selector was null or undefined when calling apiV2SelectorsEnvironmentsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.EnvironmentsApiFetchParamCreator = EnvironmentsApiFetchParamCreator;
/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
const EnvironmentsApiFp = function (configuration) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt]
         * @param {string} [defaultCluster]
         * @param {string} [defaultNamespace]
         * @param {number} [id]
         * @param {string} [lifecycle]
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability]
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt]
         * @param {string} [valuesName]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2EnvironmentsPost(body, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2EnvironmentsSelectorDelete(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2EnvironmentsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body, selector, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2EnvironmentsSelectorPatch(body, selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector, options) {
            const localVarFetchArgs = (0, exports.EnvironmentsApiFetchParamCreator)(configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.EnvironmentsApiFp = EnvironmentsApiFp;
/**
 * EnvironmentsApi - factory interface
 * @export
 */
const EnvironmentsApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt]
         * @param {string} [defaultCluster]
         * @param {string} [defaultNamespace]
         * @param {number} [id]
         * @param {string} [lifecycle]
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability]
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt]
         * @param {string} [valuesName]
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2EnvironmentsPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2EnvironmentsSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2EnvironmentsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body, selector, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2EnvironmentsSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector, options) {
            return (0, exports.EnvironmentsApiFp)(configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};
exports.EnvironmentsApiFactory = EnvironmentsApiFactory;
/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
class EnvironmentsApi extends BaseAPI {
    /**
     * List existing Environment entries, ordered by most recently updated.
     * @summary List Environment entries
     * @param {string} [base] Required when creating
     * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
     * @param {string} [createdAt]
     * @param {string} [defaultCluster]
     * @param {string} [defaultNamespace]
     * @param {number} [id]
     * @param {string} [lifecycle]
     * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
     * @param {string} [owner] When creating, will be set to your email
     * @param {boolean} [requiresSuitability]
     * @param {string} [templateEnvironment] Required for dynamic environments
     * @param {string} [updatedAt]
     * @param {string} [valuesName]
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options)(this.fetch, this.basePath);
    }
    /**
     * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
     * @summary Create a new Environment entry
     * @param {V2controllersCreatableEnvironment} body The Environment to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2EnvironmentsPost(body, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2EnvironmentsPost(body, options)(this.fetch, this.basePath);
    }
    /**
     * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Environment entry
     * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2EnvironmentsSelectorDelete(selector, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2EnvironmentsSelectorDelete(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Environment entry
     * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2EnvironmentsSelectorGet(selector, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2EnvironmentsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
    /**
     * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Environment entry
     * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
     * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2EnvironmentsSelectorPatch(body, selector, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2EnvironmentsSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }
    /**
     * Validate a given Environment selector and provide any other selectors that would match the same Environment.
     * @summary List Environment selectors
     * @param {string} selector The selector of the Environment to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    apiV2SelectorsEnvironmentsSelectorGet(selector, options) {
        return (0, exports.EnvironmentsApiFp)(this.configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options)(this.fetch, this.basePath);
    }
}
exports.EnvironmentsApi = EnvironmentsApi;
/**
 * MiscApi - fetch parameter creator
 * @export
 */
const MiscApiFetchParamCreator = function (configuration) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options = {}) {
            const localVarPath = `/my-user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options = {}) {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options = {}) {
            const localVarPath = `/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.MiscApiFetchParamCreator = MiscApiFetchParamCreator;
/**
 * MiscApi - functional programming interface
 * @export
 */
const MiscApiFp = function (configuration) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options) {
            const localVarFetchArgs = (0, exports.MiscApiFetchParamCreator)(configuration).myUserGet(options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options) {
            const localVarFetchArgs = (0, exports.MiscApiFetchParamCreator)(configuration).statusGet(options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options) {
            const localVarFetchArgs = (0, exports.MiscApiFetchParamCreator)(configuration).versionGet(options);
            return (fetch = isomorphicFetch, basePath = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    }
                    else {
                        throw response;
                    }
                });
            };
        },
    };
};
exports.MiscApiFp = MiscApiFp;
/**
 * MiscApi - factory interface
 * @export
 */
const MiscApiFactory = function (configuration, fetch, basePath) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options) {
            return (0, exports.MiscApiFp)(configuration).myUserGet(options)(fetch, basePath);
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options) {
            return (0, exports.MiscApiFp)(configuration).statusGet(options)(fetch, basePath);
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options) {
            return (0, exports.MiscApiFp)(configuration).versionGet(options)(fetch, basePath);
        },
    };
};
exports.MiscApiFactory = MiscApiFactory;
/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
class MiscApi extends BaseAPI {
    /**
     * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
     * @summary Get information about the calling user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    myUserGet(options) {
        return (0, exports.MiscApiFp)(this.configuration).myUserGet(options)(this.fetch, this.basePath);
    }
    /**
     * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
     * @summary Get Sherlock's current status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    statusGet(options) {
        return (0, exports.MiscApiFp)(this.configuration).statusGet(options)(this.fetch, this.basePath);
    }
    /**
     * Get the build version of this Sherlock instance.
     * @summary Get Sherlock's own current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    versionGet(options) {
        return (0, exports.MiscApiFp)(this.configuration).versionGet(options)(this.fetch, this.basePath);
    }
}
exports.MiscApi = MiscApi;
