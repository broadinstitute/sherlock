/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Sherlock
 * The Data Science Platform's source-of-truth service
 *
 * OpenAPI spec version: development
 * Contact: dsp-devops@broadinstitute.org
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AuthExtraPermissions
 */
export interface AuthExtraPermissions {
    /**
     * 
     * @type {boolean}
     * @memberof AuthExtraPermissions
     */
    suitable?: boolean;
}
/**
 * 
 * @export
 * @interface AuthFirecloudAccount
 */
export interface AuthFirecloudAccount {
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudAccount
     */
    acceptedGoogleTerms?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudAccount
     */
    archived?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthFirecloudAccount
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudAccount
     */
    enrolledIn2Fa?: boolean;
    /**
     * 
     * @type {AuthFirecloudGroupMembership}
     * @memberof AuthFirecloudAccount
     */
    groups?: AuthFirecloudGroupMembership;
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudAccount
     */
    suspended?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthFirecloudAccount
     */
    suspensionReason?: string;
}
/**
 * 
 * @export
 * @interface AuthFirecloudGroupMembership
 */
export interface AuthFirecloudGroupMembership {
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudGroupMembership
     */
    fcAdmins?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AuthFirecloudGroupMembership
     */
    firecloudProjectOwners?: boolean;
}
/**
 * 
 * @export
 * @interface AuthUser
 */
export interface AuthUser {
    /**
     * 
     * @type {string}
     * @memberof AuthUser
     */
    authenticatedEmail?: string;
    /**
     * 
     * @type {AuthExtraPermissions}
     * @memberof AuthUser
     */
    matchedExtraPermissions?: AuthExtraPermissions;
    /**
     * 
     * @type {AuthFirecloudAccount}
     * @memberof AuthUser
     */
    matchedFirecloudAccount?: AuthFirecloudAccount;
}
/**
 * 
 * @export
 * @interface ErrorsErrorResponse
 */
export interface ErrorsErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ErrorsErrorResponse
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorsErrorResponse
     */
    toBlame?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorsErrorResponse
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface MiscMyUserResponse
 */
export interface MiscMyUserResponse {
    /**
     * 
     * @type {string}
     * @memberof MiscMyUserResponse
     */
    email?: string;
    /**
     * 
     * @type {AuthUser}
     * @memberof MiscMyUserResponse
     */
    rawInfo?: AuthUser;
    /**
     * 
     * @type {string}
     * @memberof MiscMyUserResponse
     */
    suitability?: string;
}
/**
 * 
 * @export
 * @interface MiscStatusResponse
 */
export interface MiscStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof MiscStatusResponse
     */
    ok?: boolean;
}
/**
 * 
 * @export
 * @interface MiscVersionResponse
 */
export interface MiscVersionResponse {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MiscVersionResponse
     */
    buildInfo?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof MiscVersionResponse
     */
    goVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof MiscVersionResponse
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface V2controllersAppVersion
 */
export interface V2controllersAppVersion {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    appVersion?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    chart?: string;
    /**
     * 
     * @type {V2controllersChart}
     * @memberof V2controllersAppVersion
     */
    chartInfo?: V2controllersChart;
    /**
     * 
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    gitBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    gitCommit?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersAppVersion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof V2controllersAppVersion
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface V2controllersChart
 */
export interface V2controllersChart {
    /**
     * 
     * @type {string}
     * @memberof V2controllersChart
     */
    appImageGitMainBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChart
     */
    appImageGitRepo?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChart
     */
    chartRepo?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChart
     */
    createdAt?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersChart
     */
    id?: number;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersChart
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChart
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface V2controllersChartDeployRecord
 */
export interface V2controllersChartDeployRecord {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    chartRelease?: string;
    /**
     * 
     * @type {V2controllersChartRelease}
     * @memberof V2controllersChartDeployRecord
     */
    chartReleaseInfo?: V2controllersChartRelease;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    createdAt?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    exactAppVersion?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    exactChartVersion?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    helmfileRef?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersChartDeployRecord
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartDeployRecord
     */
    updatedAt?: string;
}
/**
 * 
 * @export
 * @interface V2controllersChartRelease
 */
export interface V2controllersChartRelease {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    chart?: string;
    /**
     * 
     * @type {V2controllersChart}
     * @memberof V2controllersChartRelease
     */
    chartInfo?: V2controllersChart;
    /**
     * When creating, will default the environment's default cluster, if provided. Either this or environment must be provided.
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    cluster?: string;
    /**
     * 
     * @type {V2controllersCluster}
     * @memberof V2controllersChartRelease
     */
    clusterInfo?: V2controllersCluster;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    currentAppVersionExact?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    currentChartVersionExact?: string;
    /**
     * Calculated field
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    destinationType?: string;
    /**
     * Either this or cluster must be provided.
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    environment?: string;
    /**
     * 
     * @type {V2controllersEnvironment}
     * @memberof V2controllersChartRelease
     */
    environmentInfo?: V2controllersEnvironment;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    helmfileRef?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersChartRelease
     */
    id?: number;
    /**
     * When creating, will be calculated if left empty
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    name?: string;
    /**
     * When creating, will default to the environment's default namespace, if provided
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    namespace?: string;
    /**
     * When creating, will default to the app's main branch if it has one recorded
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetAppVersionBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetAppVersionCommit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetAppVersionExact?: string;
    /**
     * When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetAppVersionUse?: V2controllersChartRelease.TargetAppVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetChartVersionExact?: string;
    /**
     * When creating, will default to latest unless an exact target chart version is provided
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    targetChartVersionUse?: V2controllersChartRelease.TargetChartVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    thelmaMode?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartRelease
     */
    updatedAt?: string;
}

/**
 * @export
 * @namespace V2controllersChartRelease
 */
export namespace V2controllersChartRelease {
    /**
     * @export
     * @enum {string}
     */
    export enum TargetAppVersionUseEnum {
        Branch = <any> 'branch',
        Commit = <any> 'commit',
        Exact = <any> 'exact'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TargetChartVersionUseEnum {
        Latest = <any> 'latest',
        Exact = <any> 'exact'
    }
}
/**
 * 
 * @export
 * @interface V2controllersChartVersion
 */
export interface V2controllersChartVersion {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersChartVersion
     */
    chart?: string;
    /**
     * 
     * @type {V2controllersChart}
     * @memberof V2controllersChartVersion
     */
    chartInfo?: V2controllersChart;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersChartVersion
     */
    chartVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartVersion
     */
    createdAt?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersChartVersion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof V2controllersChartVersion
     */
    updatedAt?: string;
}
/**
 * The full set of Cluster fields that can be read or used for filtering queries
 * @export
 * @interface V2controllersCluster
 */
export interface V2controllersCluster {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCluster
     */
    address?: string;
    /**
     * Required when creating if providers is 'azure'
     * @type {string}
     * @memberof V2controllersCluster
     */
    azureSubscription?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCluster
     */
    base?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCluster
     */
    createdAt?: string;
    /**
     * Required when creating if provider is 'google'
     * @type {string}
     * @memberof V2controllersCluster
     */
    googleProject?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersCluster
     */
    id?: number;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCluster
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCluster
     */
    provider?: V2controllersCluster.ProviderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersCluster
     */
    requiresSuitability?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCluster
     */
    updatedAt?: string;
}

/**
 * @export
 * @namespace V2controllersCluster
 */
export namespace V2controllersCluster {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderEnum {
        Google = <any> 'google',
        Azure = <any> 'azure'
    }
}
/**
 * 
 * @export
 * @interface V2controllersCreatableAppVersion
 */
export interface V2controllersCreatableAppVersion {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableAppVersion
     */
    appVersion?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableAppVersion
     */
    chart?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableAppVersion
     */
    gitBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableAppVersion
     */
    gitCommit?: string;
}
/**
 * 
 * @export
 * @interface V2controllersCreatableChart
 */
export interface V2controllersCreatableChart {
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChart
     */
    appImageGitMainBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChart
     */
    appImageGitRepo?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChart
     */
    chartRepo?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableChart
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface V2controllersCreatableChartDeployRecord
 */
export interface V2controllersCreatableChartDeployRecord {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableChartDeployRecord
     */
    chartRelease?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersCreatableChartDeployRecord
     */
    exactAppVersion?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersCreatableChartDeployRecord
     */
    exactChartVersion?: string;
    /**
     * When creating, will default to the value currently held by the chart release
     * @type {string}
     * @memberof V2controllersCreatableChartDeployRecord
     */
    helmfileRef?: string;
}
/**
 * 
 * @export
 * @interface V2controllersCreatableChartRelease
 */
export interface V2controllersCreatableChartRelease {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    chart?: string;
    /**
     * When creating, will default the environment's default cluster, if provided. Either this or environment must be provided.
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    cluster?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    currentAppVersionExact?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    currentChartVersionExact?: string;
    /**
     * Either this or cluster must be provided.
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    environment?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    helmfileRef?: string;
    /**
     * When creating, will be calculated if left empty
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    name?: string;
    /**
     * When creating, will default to the environment's default namespace, if provided
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    namespace?: string;
    /**
     * When creating, will default to the app's main branch if it has one recorded
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetAppVersionBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetAppVersionCommit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetAppVersionExact?: string;
    /**
     * When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetAppVersionUse?: V2controllersCreatableChartRelease.TargetAppVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetChartVersionExact?: string;
    /**
     * When creating, will default to latest unless an exact target chart version is provided
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    targetChartVersionUse?: V2controllersCreatableChartRelease.TargetChartVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableChartRelease
     */
    thelmaMode?: string;
}

/**
 * @export
 * @namespace V2controllersCreatableChartRelease
 */
export namespace V2controllersCreatableChartRelease {
    /**
     * @export
     * @enum {string}
     */
    export enum TargetAppVersionUseEnum {
        Branch = <any> 'branch',
        Commit = <any> 'commit',
        Exact = <any> 'exact'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TargetChartVersionUseEnum {
        Latest = <any> 'latest',
        Exact = <any> 'exact'
    }
}
/**
 * 
 * @export
 * @interface V2controllersCreatableChartVersion
 */
export interface V2controllersCreatableChartVersion {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableChartVersion
     */
    chart?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableChartVersion
     */
    chartVersion?: string;
}
/**
 * The subset of Cluster fields that can be set upon creation
 * @export
 * @interface V2controllersCreatableCluster
 */
export interface V2controllersCreatableCluster {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    address?: string;
    /**
     * Required when creating if providers is 'azure'
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    azureSubscription?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    base?: string;
    /**
     * Required when creating if provider is 'google'
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    googleProject?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableCluster
     */
    provider?: V2controllersCreatableCluster.ProviderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersCreatableCluster
     */
    requiresSuitability?: boolean;
}

/**
 * @export
 * @namespace V2controllersCreatableCluster
 */
export namespace V2controllersCreatableCluster {
    /**
     * @export
     * @enum {string}
     */
    export enum ProviderEnum {
        Google = <any> 'google',
        Azure = <any> 'azure'
    }
}
/**
 * 
 * @export
 * @interface V2controllersCreatableEnvironment
 */
export interface V2controllersCreatableEnvironment {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    base?: string;
    /**
     * Upon creation of a dynamic environment, if this is true the template's chart releases will be copied to the new environment
     * @type {boolean}
     * @memberof V2controllersCreatableEnvironment
     */
    chartReleasesFromTemplate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    defaultCluster?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    defaultNamespace?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    lifecycle?: string;
    /**
     * When creating, will be calculated if dynamic, required otherwise
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    name?: string;
    /**
     * When creating, will be set to your email
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    owner?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersCreatableEnvironment
     */
    requiresSuitability?: boolean;
    /**
     * Required for dynamic environments
     * @type {string}
     * @memberof V2controllersCreatableEnvironment
     */
    templateEnvironment?: string;
}
/**
 * 
 * @export
 * @interface V2controllersEditableChart
 */
export interface V2controllersEditableChart {
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChart
     */
    appImageGitMainBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChart
     */
    appImageGitRepo?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChart
     */
    chartRepo?: string;
}
/**
 * 
 * @export
 * @interface V2controllersEditableChartRelease
 */
export interface V2controllersEditableChartRelease {
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    currentAppVersionExact?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    currentChartVersionExact?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    helmfileRef?: string;
    /**
     * When creating, will default to the app's main branch if it has one recorded
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetAppVersionBranch?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetAppVersionCommit?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetAppVersionExact?: string;
    /**
     * When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetAppVersionUse?: V2controllersEditableChartRelease.TargetAppVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetChartVersionExact?: string;
    /**
     * When creating, will default to latest unless an exact target chart version is provided
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    targetChartVersionUse?: V2controllersEditableChartRelease.TargetChartVersionUseEnum;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableChartRelease
     */
    thelmaMode?: string;
}

/**
 * @export
 * @namespace V2controllersEditableChartRelease
 */
export namespace V2controllersEditableChartRelease {
    /**
     * @export
     * @enum {string}
     */
    export enum TargetAppVersionUseEnum {
        Branch = <any> 'branch',
        Commit = <any> 'commit',
        Exact = <any> 'exact'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TargetChartVersionUseEnum {
        Latest = <any> 'latest',
        Exact = <any> 'exact'
    }
}
/**
 * The subset of Cluster fields that can be edited after creation
 * @export
 * @interface V2controllersEditableCluster
 */
export interface V2controllersEditableCluster {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersEditableCluster
     */
    address?: string;
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersEditableCluster
     */
    base?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersEditableCluster
     */
    requiresSuitability?: boolean;
}
/**
 * 
 * @export
 * @interface V2controllersEditableEnvironment
 */
export interface V2controllersEditableEnvironment {
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableEnvironment
     */
    defaultCluster?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEditableEnvironment
     */
    defaultNamespace?: string;
    /**
     * When creating, will be set to your email
     * @type {string}
     * @memberof V2controllersEditableEnvironment
     */
    owner?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersEditableEnvironment
     */
    requiresSuitability?: boolean;
}
/**
 * 
 * @export
 * @interface V2controllersEnvironment
 */
export interface V2controllersEnvironment {
    /**
     * Required when creating
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    base?: string;
    /**
     * Upon creation of a dynamic environment, if this is true the template's chart releases will be copied to the new environment
     * @type {boolean}
     * @memberof V2controllersEnvironment
     */
    chartReleasesFromTemplate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    createdAt?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    defaultCluster?: string;
    /**
     * 
     * @type {V2controllersCluster}
     * @memberof V2controllersEnvironment
     */
    defaultClusterInfo?: V2controllersCluster;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    defaultNamespace?: string;
    /**
     * 
     * @type {number}
     * @memberof V2controllersEnvironment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    lifecycle?: string;
    /**
     * When creating, will be calculated if dynamic, required otherwise
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    name?: string;
    /**
     * When creating, will be set to your email
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    owner?: string;
    /**
     * 
     * @type {boolean}
     * @memberof V2controllersEnvironment
     */
    requiresSuitability?: boolean;
    /**
     * Required for dynamic environments
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    templateEnvironment?: string;
    /**
     * Single-layer recursive; provides info of the template environment if this environment has one
     * @type {any}
     * @memberof V2controllersEnvironment
     */
    templateEnvironmentInfo?: any;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    updatedAt?: string;
    /**
     * 
     * @type {string}
     * @memberof V2controllersEnvironment
     */
    valuesName?: string;
}
/**
 * AppVersionsApi - fetch parameter creator
 * @export
 */
export const AppVersionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [gitBranch] 
         * @param {string} [gitCommit] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion?: string, chart?: string, createdAt?: string, gitBranch?: string, gitCommit?: string, id?: number, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/app-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appVersion !== undefined) {
                localVarQueryParameter['appVersion'] = appVersion;
            }

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (gitBranch !== undefined) {
                localVarQueryParameter['gitBranch'] = gitBranch;
            }

            if (gitCommit !== undefined) {
                localVarQueryParameter['gitCommit'] = gitCommit;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body: V2controllersCreatableAppVersion, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2AppVersionsPost.');
            }
            const localVarPath = `/api/v2/app-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableAppVersion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2AppVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/app-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsAppVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/app-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppVersionsApi - functional programming interface
 * @export
 */
export const AppVersionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [gitBranch] 
         * @param {string} [gitCommit] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion?: string, chart?: string, createdAt?: string, gitBranch?: string, gitCommit?: string, id?: number, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersAppVersion>> {
            const localVarFetchArgs = AppVersionsApiFetchParamCreator(configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body: V2controllersCreatableAppVersion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersAppVersion> {
            const localVarFetchArgs = AppVersionsApiFetchParamCreator(configuration).apiV2AppVersionsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersAppVersion> {
            const localVarFetchArgs = AppVersionsApiFetchParamCreator(configuration).apiV2AppVersionsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = AppVersionsApiFetchParamCreator(configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppVersionsApi - factory interface
 * @export
 */
export const AppVersionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing AppVersion entries, ordered by most recently updated.
         * @summary List AppVersion entries
         * @param {string} [appVersion] Required when creating
         * @param {string} [chart] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [gitBranch] 
         * @param {string} [gitCommit] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsGet(appVersion?: string, chart?: string, createdAt?: string, gitBranch?: string, gitCommit?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
            return AppVersionsApiFp(configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new AppVersion entry. Note that fields are immutable after creation.
         * @summary Create a new AppVersion entry
         * @param {V2controllersCreatableAppVersion} body The AppVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsPost(body: V2controllersCreatableAppVersion, options?: any) {
            return AppVersionsApiFp(configuration).apiV2AppVersionsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a AppVersion entry
         * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2AppVersionsSelectorGet(selector: string, options?: any) {
            return AppVersionsApiFp(configuration).apiV2AppVersionsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
         * @summary List AppVersion selectors
         * @param {string} selector The selector of the AppVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsAppVersionsSelectorGet(selector: string, options?: any) {
            return AppVersionsApiFp(configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * AppVersionsApi - object-oriented interface
 * @export
 * @class AppVersionsApi
 * @extends {BaseAPI}
 */
export class AppVersionsApi extends BaseAPI {
    /**
     * List existing AppVersion entries, ordered by most recently updated.
     * @summary List AppVersion entries
     * @param {string} [appVersion] Required when creating
     * @param {string} [chart] Required when creating
     * @param {string} [createdAt] 
     * @param {string} [gitBranch] 
     * @param {string} [gitCommit] 
     * @param {number} [id] 
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public apiV2AppVersionsGet(appVersion?: string, chart?: string, createdAt?: string, gitBranch?: string, gitCommit?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
        return AppVersionsApiFp(this.configuration).apiV2AppVersionsGet(appVersion, chart, createdAt, gitBranch, gitCommit, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new AppVersion entry. Note that fields are immutable after creation.
     * @summary Create a new AppVersion entry
     * @param {V2controllersCreatableAppVersion} body The AppVersion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public apiV2AppVersionsPost(body: V2controllersCreatableAppVersion, options?: any) {
        return AppVersionsApiFp(this.configuration).apiV2AppVersionsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing AppVersion entry via one its \"selector\"--its numeric ID.
     * @summary Get a AppVersion entry
     * @param {string} selector The AppVersion to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public apiV2AppVersionsSelectorGet(selector: string, options?: any) {
        return AppVersionsApiFp(this.configuration).apiV2AppVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given AppVersion selector and provide any other selectors that would match the same AppVersion.
     * @summary List AppVersion selectors
     * @param {string} selector The selector of the AppVersion to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppVersionsApi
     */
    public apiV2SelectorsAppVersionsSelectorGet(selector: string, options?: any) {
        return AppVersionsApiFp(this.configuration).apiV2SelectorsAppVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * ChartDeployRecordsApi - fetch parameter creator
 * @export
 */
export const ChartDeployRecordsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease?: string, createdAt?: string, exactAppVersion?: string, exactChartVersion?: string, helmfileRef?: string, id?: number, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/chart-deploy-records`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chartRelease !== undefined) {
                localVarQueryParameter['chartRelease'] = chartRelease;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (exactAppVersion !== undefined) {
                localVarQueryParameter['exactAppVersion'] = exactAppVersion;
            }

            if (exactChartVersion !== undefined) {
                localVarQueryParameter['exactChartVersion'] = exactChartVersion;
            }

            if (helmfileRef !== undefined) {
                localVarQueryParameter['helmfileRef'] = helmfileRef;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body: V2controllersCreatableChartDeployRecord, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartDeployRecordsPost.');
            }
            const localVarPath = `/api/v2/chart-deploy-records`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableChartDeployRecord" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartDeployRecordsSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-deploy-records/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsChartDeployRecordsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-deploy-records/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartDeployRecordsApi - functional programming interface
 * @export
 */
export const ChartDeployRecordsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease?: string, createdAt?: string, exactAppVersion?: string, exactChartVersion?: string, helmfileRef?: string, id?: number, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersChartDeployRecord>> {
            const localVarFetchArgs = ChartDeployRecordsApiFetchParamCreator(configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body: V2controllersCreatableChartDeployRecord, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartDeployRecord> {
            const localVarFetchArgs = ChartDeployRecordsApiFetchParamCreator(configuration).apiV2ChartDeployRecordsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartDeployRecord> {
            const localVarFetchArgs = ChartDeployRecordsApiFetchParamCreator(configuration).apiV2ChartDeployRecordsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ChartDeployRecordsApiFetchParamCreator(configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartDeployRecordsApi - factory interface
 * @export
 */
export const ChartDeployRecordsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing ChartDeployRecord entries, ordered by most recently updated.
         * @summary List ChartDeployRecord entries
         * @param {string} [chartRelease] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
         * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsGet(chartRelease?: string, createdAt?: string, exactAppVersion?: string, exactChartVersion?: string, helmfileRef?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
            return ChartDeployRecordsApiFp(configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
         * @summary Create a new ChartDeployRecord entry
         * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsPost(body: V2controllersCreatableChartDeployRecord, options?: any) {
            return ChartDeployRecordsApiFp(configuration).apiV2ChartDeployRecordsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartDeployRecord entry
         * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartDeployRecordsSelectorGet(selector: string, options?: any) {
            return ChartDeployRecordsApiFp(configuration).apiV2ChartDeployRecordsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
         * @summary List ChartDeployRecord selectors
         * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartDeployRecordsSelectorGet(selector: string, options?: any) {
            return ChartDeployRecordsApiFp(configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * ChartDeployRecordsApi - object-oriented interface
 * @export
 * @class ChartDeployRecordsApi
 * @extends {BaseAPI}
 */
export class ChartDeployRecordsApi extends BaseAPI {
    /**
     * List existing ChartDeployRecord entries, ordered by most recently updated.
     * @summary List ChartDeployRecord entries
     * @param {string} [chartRelease] Required when creating
     * @param {string} [createdAt] 
     * @param {string} [exactAppVersion] When creating, will default to the value currently held by the chart release
     * @param {string} [exactChartVersion] When creating, will default to the value currently held by the chart release
     * @param {string} [helmfileRef] When creating, will default to the value currently held by the chart release
     * @param {number} [id] 
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    public apiV2ChartDeployRecordsGet(chartRelease?: string, createdAt?: string, exactAppVersion?: string, exactChartVersion?: string, helmfileRef?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
        return ChartDeployRecordsApiFp(this.configuration).apiV2ChartDeployRecordsGet(chartRelease, createdAt, exactAppVersion, exactChartVersion, helmfileRef, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new ChartDeployRecord entry. Note that fields are immutable after creation.
     * @summary Create a new ChartDeployRecord entry
     * @param {V2controllersCreatableChartDeployRecord} body The ChartDeployRecord to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    public apiV2ChartDeployRecordsPost(body: V2controllersCreatableChartDeployRecord, options?: any) {
        return ChartDeployRecordsApiFp(this.configuration).apiV2ChartDeployRecordsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing ChartDeployRecord entry via one its \"selector\"--its numeric ID.
     * @summary Get a ChartDeployRecord entry
     * @param {string} selector The ChartDeployRecord to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    public apiV2ChartDeployRecordsSelectorGet(selector: string, options?: any) {
        return ChartDeployRecordsApiFp(this.configuration).apiV2ChartDeployRecordsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given ChartDeployRecord selector and provide any other selectors that would match the same ChartDeployRecord.
     * @summary List ChartDeployRecord selectors
     * @param {string} selector The selector of the ChartDeployRecord to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDeployRecordsApi
     */
    public apiV2SelectorsChartDeployRecordsSelectorGet(selector: string, options?: any) {
        return ChartDeployRecordsApiFp(this.configuration).apiV2SelectorsChartDeployRecordsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * ChartReleasesApi - fetch parameter creator
 * @export
 */
export const ChartReleasesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt] 
         * @param {string} [currentAppVersionExact] 
         * @param {string} [currentChartVersionExact] 
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef] 
         * @param {number} [id] 
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit] 
         * @param {string} [targetAppVersionExact] 
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact] 
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart?: string, cluster?: string, createdAt?: string, currentAppVersionExact?: string, currentChartVersionExact?: string, destinationType?: string, environment?: string, helmfileRef?: string, id?: number, name?: string, namespace?: string, targetAppVersionBranch?: string, targetAppVersionCommit?: string, targetAppVersionExact?: string, targetAppVersionUse?: string, targetChartVersionExact?: string, targetChartVersionUse?: string, thelmaMode?: string, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/chart-releases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (currentAppVersionExact !== undefined) {
                localVarQueryParameter['currentAppVersionExact'] = currentAppVersionExact;
            }

            if (currentChartVersionExact !== undefined) {
                localVarQueryParameter['currentChartVersionExact'] = currentChartVersionExact;
            }

            if (destinationType !== undefined) {
                localVarQueryParameter['destinationType'] = destinationType;
            }

            if (environment !== undefined) {
                localVarQueryParameter['environment'] = environment;
            }

            if (helmfileRef !== undefined) {
                localVarQueryParameter['helmfileRef'] = helmfileRef;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (namespace !== undefined) {
                localVarQueryParameter['namespace'] = namespace;
            }

            if (targetAppVersionBranch !== undefined) {
                localVarQueryParameter['targetAppVersionBranch'] = targetAppVersionBranch;
            }

            if (targetAppVersionCommit !== undefined) {
                localVarQueryParameter['targetAppVersionCommit'] = targetAppVersionCommit;
            }

            if (targetAppVersionExact !== undefined) {
                localVarQueryParameter['targetAppVersionExact'] = targetAppVersionExact;
            }

            if (targetAppVersionUse !== undefined) {
                localVarQueryParameter['targetAppVersionUse'] = targetAppVersionUse;
            }

            if (targetChartVersionExact !== undefined) {
                localVarQueryParameter['targetChartVersionExact'] = targetChartVersionExact;
            }

            if (targetChartVersionUse !== undefined) {
                localVarQueryParameter['targetChartVersionUse'] = targetChartVersionUse;
            }

            if (thelmaMode !== undefined) {
                localVarQueryParameter['thelmaMode'] = thelmaMode;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body: V2controllersCreatableChartRelease, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartReleasesPost.');
            }
            const localVarPath = `/api/v2/chart-releases`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableChartRelease" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorDelete.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body: V2controllersEditableChartRelease, selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartReleasesSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartReleasesSelectorPatch.');
            }
            const localVarPath = `/api/v2/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersEditableChartRelease" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsChartReleasesSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-releases/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartReleasesApi - functional programming interface
 * @export
 */
export const ChartReleasesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt] 
         * @param {string} [currentAppVersionExact] 
         * @param {string} [currentChartVersionExact] 
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef] 
         * @param {number} [id] 
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit] 
         * @param {string} [targetAppVersionExact] 
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact] 
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart?: string, cluster?: string, createdAt?: string, currentAppVersionExact?: string, currentChartVersionExact?: string, destinationType?: string, environment?: string, helmfileRef?: string, id?: number, name?: string, namespace?: string, targetAppVersionBranch?: string, targetAppVersionCommit?: string, targetAppVersionExact?: string, targetAppVersionUse?: string, targetChartVersionExact?: string, targetChartVersionUse?: string, thelmaMode?: string, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersChartRelease>> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body: V2controllersCreatableChartRelease, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartRelease> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2ChartReleasesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartRelease> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2ChartReleasesSelectorDelete(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartRelease> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2ChartReleasesSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body: V2controllersEditableChartRelease, selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartRelease> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2ChartReleasesSelectorPatch(body, selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ChartReleasesApiFetchParamCreator(configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartReleasesApi - factory interface
 * @export
 */
export const ChartReleasesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing ChartRelease entries, ordered by most recently updated.
         * @summary List ChartRelease entries
         * @param {string} [chart] Required when creating
         * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
         * @param {string} [createdAt] 
         * @param {string} [currentAppVersionExact] 
         * @param {string} [currentChartVersionExact] 
         * @param {string} [destinationType] Calculated field
         * @param {string} [environment] Either this or cluster must be provided.
         * @param {string} [helmfileRef] 
         * @param {number} [id] 
         * @param {string} [name] When creating, will be calculated if left empty
         * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
         * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
         * @param {string} [targetAppVersionCommit] 
         * @param {string} [targetAppVersionExact] 
         * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
         * @param {string} [targetChartVersionExact] 
         * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
         * @param {string} [thelmaMode] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesGet(chart?: string, cluster?: string, createdAt?: string, currentAppVersionExact?: string, currentChartVersionExact?: string, destinationType?: string, environment?: string, helmfileRef?: string, id?: number, name?: string, namespace?: string, targetAppVersionBranch?: string, targetAppVersionCommit?: string, targetAppVersionExact?: string, targetAppVersionUse?: string, targetChartVersionExact?: string, targetChartVersionUse?: string, thelmaMode?: string, updatedAt?: string, limit?: number, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new ChartRelease entry
         * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesPost(body: V2controllersCreatableChartRelease, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2ChartReleasesPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Delete a ChartRelease entry
         * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorDelete(selector: string, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2ChartReleasesSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
         * @summary Get a ChartRelease entry
         * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorGet(selector: string, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2ChartReleasesSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a ChartRelease entry
         * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
         * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartReleasesSelectorPatch(body: V2controllersEditableChartRelease, selector: string, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2ChartReleasesSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
         * @summary List ChartRelease selectors
         * @param {string} selector The selector of the ChartRelease to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartReleasesSelectorGet(selector: string, options?: any) {
            return ChartReleasesApiFp(configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * ChartReleasesApi - object-oriented interface
 * @export
 * @class ChartReleasesApi
 * @extends {BaseAPI}
 */
export class ChartReleasesApi extends BaseAPI {
    /**
     * List existing ChartRelease entries, ordered by most recently updated.
     * @summary List ChartRelease entries
     * @param {string} [chart] Required when creating
     * @param {string} [cluster] When creating, will default the environment&#x27;s default cluster, if provided. Either this or environment must be provided.
     * @param {string} [createdAt] 
     * @param {string} [currentAppVersionExact] 
     * @param {string} [currentChartVersionExact] 
     * @param {string} [destinationType] Calculated field
     * @param {string} [environment] Either this or cluster must be provided.
     * @param {string} [helmfileRef] 
     * @param {number} [id] 
     * @param {string} [name] When creating, will be calculated if left empty
     * @param {string} [namespace] When creating, will default to the environment&#x27;s default namespace, if provided
     * @param {string} [targetAppVersionBranch] When creating, will default to the app&#x27;s main branch if it has one recorded
     * @param {string} [targetAppVersionCommit] 
     * @param {string} [targetAppVersionExact] 
     * @param {string} [targetAppVersionUse] When creating, will default to referencing any provided target app version field (exact, then commit, then branch)
     * @param {string} [targetChartVersionExact] 
     * @param {string} [targetChartVersionUse] When creating, will default to latest unless an exact target chart version is provided
     * @param {string} [thelmaMode] 
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2ChartReleasesGet(chart?: string, cluster?: string, createdAt?: string, currentAppVersionExact?: string, currentChartVersionExact?: string, destinationType?: string, environment?: string, helmfileRef?: string, id?: number, name?: string, namespace?: string, targetAppVersionBranch?: string, targetAppVersionCommit?: string, targetAppVersionExact?: string, targetAppVersionUse?: string, targetChartVersionExact?: string, targetChartVersionUse?: string, thelmaMode?: string, updatedAt?: string, limit?: number, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2ChartReleasesGet(chart, cluster, createdAt, currentAppVersionExact, currentChartVersionExact, destinationType, environment, helmfileRef, id, name, namespace, targetAppVersionBranch, targetAppVersionCommit, targetAppVersionExact, targetAppVersionUse, targetChartVersionExact, targetChartVersionUse, thelmaMode, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new ChartRelease entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new ChartRelease entry
     * @param {V2controllersCreatableChartRelease} body The ChartRelease to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2ChartReleasesPost(body: V2controllersCreatableChartRelease, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2ChartReleasesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
     * @summary Delete a ChartRelease entry
     * @param {string} selector The ChartRelease to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2ChartReleasesSelectorDelete(selector: string, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2ChartReleasesSelectorDelete(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart.
     * @summary Get a ChartRelease entry
     * @param {string} selector The ChartRelease to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2ChartReleasesSelectorGet(selector: string, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2ChartReleasesSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Edit an existing ChartRelease entry via one of its \"selectors\": name, numeric ID, environment/chart, or cluster/namespace/chart. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a ChartRelease entry
     * @param {V2controllersEditableChartRelease} body The edits to make to the ChartRelease
     * @param {string} selector The ChartRelease to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2ChartReleasesSelectorPatch(body: V2controllersEditableChartRelease, selector: string, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2ChartReleasesSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given ChartRelease selector and provide any other selectors that would match the same ChartRelease.
     * @summary List ChartRelease selectors
     * @param {string} selector The selector of the ChartRelease to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartReleasesApi
     */
    public apiV2SelectorsChartReleasesSelectorGet(selector: string, options?: any) {
        return ChartReleasesApiFp(this.configuration).apiV2SelectorsChartReleasesSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * ChartVersionsApi - fetch parameter creator
 * @export
 */
export const ChartVersionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart?: string, chartVersion?: string, createdAt?: string, id?: number, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/chart-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (chart !== undefined) {
                localVarQueryParameter['chart'] = chart;
            }

            if (chartVersion !== undefined) {
                localVarQueryParameter['chartVersion'] = chartVersion;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body: V2controllersCreatableChartVersion, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartVersionsPost.');
            }
            const localVarPath = `/api/v2/chart-versions`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableChartVersion" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/chart-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsChartVersionsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/chart-versions/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartVersionsApi - functional programming interface
 * @export
 */
export const ChartVersionsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart?: string, chartVersion?: string, createdAt?: string, id?: number, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersChartVersion>> {
            const localVarFetchArgs = ChartVersionsApiFetchParamCreator(configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body: V2controllersCreatableChartVersion, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartVersion> {
            const localVarFetchArgs = ChartVersionsApiFetchParamCreator(configuration).apiV2ChartVersionsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChartVersion> {
            const localVarFetchArgs = ChartVersionsApiFetchParamCreator(configuration).apiV2ChartVersionsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ChartVersionsApiFetchParamCreator(configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartVersionsApi - factory interface
 * @export
 */
export const ChartVersionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing ChartVersion entries, ordered by most recently updated.
         * @summary List ChartVersion entries
         * @param {string} [chart] Required when creating
         * @param {string} [chartVersion] Required when creating
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsGet(chart?: string, chartVersion?: string, createdAt?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
            return ChartVersionsApiFp(configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new ChartVersion entry. Note that fields are immutable after creation.
         * @summary Create a new ChartVersion entry
         * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsPost(body: V2controllersCreatableChartVersion, options?: any) {
            return ChartVersionsApiFp(configuration).apiV2ChartVersionsPost(body, options)(fetch, basePath);
        },
        /**
         * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
         * @summary Get a ChartVersion entry
         * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartVersionsSelectorGet(selector: string, options?: any) {
            return ChartVersionsApiFp(configuration).apiV2ChartVersionsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
         * @summary List ChartVersion selectors
         * @param {string} selector The selector of the ChartVersion to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartVersionsSelectorGet(selector: string, options?: any) {
            return ChartVersionsApiFp(configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * ChartVersionsApi - object-oriented interface
 * @export
 * @class ChartVersionsApi
 * @extends {BaseAPI}
 */
export class ChartVersionsApi extends BaseAPI {
    /**
     * List existing ChartVersion entries, ordered by most recently updated.
     * @summary List ChartVersion entries
     * @param {string} [chart] Required when creating
     * @param {string} [chartVersion] Required when creating
     * @param {string} [createdAt] 
     * @param {number} [id] 
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    public apiV2ChartVersionsGet(chart?: string, chartVersion?: string, createdAt?: string, id?: number, updatedAt?: string, limit?: number, options?: any) {
        return ChartVersionsApiFp(this.configuration).apiV2ChartVersionsGet(chart, chartVersion, createdAt, id, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new ChartVersion entry. Note that fields are immutable after creation.
     * @summary Create a new ChartVersion entry
     * @param {V2controllersCreatableChartVersion} body The ChartVersion to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    public apiV2ChartVersionsPost(body: V2controllersCreatableChartVersion, options?: any) {
        return ChartVersionsApiFp(this.configuration).apiV2ChartVersionsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing ChartVersion entry via one its \"selector\"--its numeric ID.
     * @summary Get a ChartVersion entry
     * @param {string} selector The ChartVersion to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    public apiV2ChartVersionsSelectorGet(selector: string, options?: any) {
        return ChartVersionsApiFp(this.configuration).apiV2ChartVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given ChartVersion selector and provide any other selectors that would match the same ChartVersion.
     * @summary List ChartVersion selectors
     * @param {string} selector The selector of the ChartVersion to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartVersionsApi
     */
    public apiV2SelectorsChartVersionsSelectorGet(selector: string, options?: any) {
        return ChartVersionsApiFp(this.configuration).apiV2SelectorsChartVersionsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * ChartsApi - fetch parameter creator
 * @export
 */
export const ChartsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch] 
         * @param {string} [appImageGitRepo] 
         * @param {string} [chartRepo] 
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch?: string, appImageGitRepo?: string, chartRepo?: string, createdAt?: string, id?: number, name?: string, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/charts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (appImageGitMainBranch !== undefined) {
                localVarQueryParameter['appImageGitMainBranch'] = appImageGitMainBranch;
            }

            if (appImageGitRepo !== undefined) {
                localVarQueryParameter['appImageGitRepo'] = appImageGitRepo;
            }

            if (chartRepo !== undefined) {
                localVarQueryParameter['chartRepo'] = chartRepo;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body: V2controllersCreatableChart, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartsPost.');
            }
            const localVarPath = `/api/v2/charts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableChart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartsSelectorDelete.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartsSelectorGet.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body: V2controllersEditableChart, selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ChartsSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ChartsSelectorPatch.');
            }
            const localVarPath = `/api/v2/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersEditableChart" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsChartsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/charts/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartsApi - functional programming interface
 * @export
 */
export const ChartsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch] 
         * @param {string} [appImageGitRepo] 
         * @param {string} [chartRepo] 
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch?: string, appImageGitRepo?: string, chartRepo?: string, createdAt?: string, id?: number, name?: string, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersChart>> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body: V2controllersCreatableChart, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChart> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2ChartsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChart> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2ChartsSelectorDelete(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChart> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2ChartsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body: V2controllersEditableChart, selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersChart> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2ChartsSelectorPatch(body, selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ChartsApiFetchParamCreator(configuration).apiV2SelectorsChartsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ChartsApi - factory interface
 * @export
 */
export const ChartsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing Chart entries, ordered by most recently updated.
         * @summary List Chart entries
         * @param {string} [appImageGitMainBranch] 
         * @param {string} [appImageGitRepo] 
         * @param {string} [chartRepo] 
         * @param {string} [createdAt] 
         * @param {number} [id] 
         * @param {string} [name] Required when creating
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsGet(appImageGitMainBranch?: string, appImageGitRepo?: string, chartRepo?: string, createdAt?: string, id?: number, name?: string, updatedAt?: string, limit?: number, options?: any) {
            return ChartsApiFp(configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Chart entry
         * @param {V2controllersCreatableChart} body The Chart to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsPost(body: V2controllersCreatableChart, options?: any) {
            return ChartsApiFp(configuration).apiV2ChartsPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Chart entry
         * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorDelete(selector: string, options?: any) {
            return ChartsApiFp(configuration).apiV2ChartsSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Chart entry
         * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorGet(selector: string, options?: any) {
            return ChartsApiFp(configuration).apiV2ChartsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Chart entry
         * @param {V2controllersEditableChart} body The edits to make to the Chart
         * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ChartsSelectorPatch(body: V2controllersEditableChart, selector: string, options?: any) {
            return ChartsApiFp(configuration).apiV2ChartsSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Chart selector and provide any other selectors that would match the same Chart.
         * @summary List Chart selectors
         * @param {string} selector The selector of the Chart to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsChartsSelectorGet(selector: string, options?: any) {
            return ChartsApiFp(configuration).apiV2SelectorsChartsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * ChartsApi - object-oriented interface
 * @export
 * @class ChartsApi
 * @extends {BaseAPI}
 */
export class ChartsApi extends BaseAPI {
    /**
     * List existing Chart entries, ordered by most recently updated.
     * @summary List Chart entries
     * @param {string} [appImageGitMainBranch] 
     * @param {string} [appImageGitRepo] 
     * @param {string} [chartRepo] 
     * @param {string} [createdAt] 
     * @param {number} [id] 
     * @param {string} [name] Required when creating
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2ChartsGet(appImageGitMainBranch?: string, appImageGitRepo?: string, chartRepo?: string, createdAt?: string, id?: number, name?: string, updatedAt?: string, limit?: number, options?: any) {
        return ChartsApiFp(this.configuration).apiV2ChartsGet(appImageGitMainBranch, appImageGitRepo, chartRepo, createdAt, id, name, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Chart entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new Chart entry
     * @param {V2controllersCreatableChart} body The Chart to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2ChartsPost(body: V2controllersCreatableChart, options?: any) {
        return ChartsApiFp(this.configuration).apiV2ChartsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing Chart entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Chart entry
     * @param {string} selector The Chart to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2ChartsSelectorDelete(selector: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV2ChartsSelectorDelete(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing Chart entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Chart entry
     * @param {string} selector The Chart to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2ChartsSelectorGet(selector: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV2ChartsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Edit an existing Chart entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Chart entry
     * @param {V2controllersEditableChart} body The edits to make to the Chart
     * @param {string} selector The Chart to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2ChartsSelectorPatch(body: V2controllersEditableChart, selector: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV2ChartsSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given Chart selector and provide any other selectors that would match the same Chart.
     * @summary List Chart selectors
     * @param {string} selector The selector of the Chart to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartsApi
     */
    public apiV2SelectorsChartsSelectorGet(selector: string, options?: any) {
        return ChartsApiFp(this.configuration).apiV2SelectorsChartsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * ClustersApi - fetch parameter creator
 * @export
 */
export const ClustersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id] 
         * @param {string} [provider] 
         * @param {boolean} [requiresSuitability] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name: string, address?: string, azureSubscription?: string, base?: string, createdAt?: string, googleProject?: string, id?: number, provider?: string, requiresSuitability?: boolean, updatedAt?: string, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling apiV2ClustersGet.');
            }
            const localVarPath = `/api/v2/clusters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (azureSubscription !== undefined) {
                localVarQueryParameter['azureSubscription'] = azureSubscription;
            }

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (googleProject !== undefined) {
                localVarQueryParameter['googleProject'] = googleProject;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (requiresSuitability !== undefined) {
                localVarQueryParameter['requiresSuitability'] = requiresSuitability;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body: V2controllersCreatableCluster, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ClustersPost.');
            }
            const localVarPath = `/api/v2/clusters`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableCluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ClustersSelectorDelete.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ClustersSelectorGet.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body: V2controllersEditableCluster, selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2ClustersSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2ClustersSelectorPatch.');
            }
            const localVarPath = `/api/v2/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersEditableCluster" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsClustersSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/clusters/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClustersApi - functional programming interface
 * @export
 */
export const ClustersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id] 
         * @param {string} [provider] 
         * @param {boolean} [requiresSuitability] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name: string, address?: string, azureSubscription?: string, base?: string, createdAt?: string, googleProject?: string, id?: number, provider?: string, requiresSuitability?: boolean, updatedAt?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersCluster>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body: V2controllersCreatableCluster, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersCluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2ClustersPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersCluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2ClustersSelectorDelete(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersCluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2ClustersSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body: V2controllersEditableCluster, selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersCluster> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2ClustersSelectorPatch(body, selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ClustersApiFetchParamCreator(configuration).apiV2SelectorsClustersSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ClustersApi - factory interface
 * @export
 */
export const ClustersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing Cluster entries, ordered by most recently updated.
         * @summary List Cluster entries
         * @param {string} name Required when creating
         * @param {string} [address] Required when creating
         * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
         * @param {string} [base] Required when creating
         * @param {string} [createdAt] 
         * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
         * @param {number} [id] 
         * @param {string} [provider] 
         * @param {boolean} [requiresSuitability] 
         * @param {string} [updatedAt] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersGet(name: string, address?: string, azureSubscription?: string, base?: string, createdAt?: string, googleProject?: string, id?: number, provider?: string, requiresSuitability?: boolean, updatedAt?: string, limit?: number, options?: any) {
            return ClustersApiFp(configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
         * @summary Create a new Cluster entry
         * @param {V2controllersCreatableCluster} body The Cluster to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersPost(body: V2controllersCreatableCluster, options?: any) {
            return ClustersApiFp(configuration).apiV2ClustersPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Cluster entry
         * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorDelete(selector: string, options?: any) {
            return ClustersApiFp(configuration).apiV2ClustersSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Cluster entry
         * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorGet(selector: string, options?: any) {
            return ClustersApiFp(configuration).apiV2ClustersSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Cluster entry
         * @param {V2controllersEditableCluster} body The edits to make to the Cluster
         * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2ClustersSelectorPatch(body: V2controllersEditableCluster, selector: string, options?: any) {
            return ClustersApiFp(configuration).apiV2ClustersSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
         * @summary List Cluster selectors
         * @param {string} selector The selector of the Cluster to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsClustersSelectorGet(selector: string, options?: any) {
            return ClustersApiFp(configuration).apiV2SelectorsClustersSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * ClustersApi - object-oriented interface
 * @export
 * @class ClustersApi
 * @extends {BaseAPI}
 */
export class ClustersApi extends BaseAPI {
    /**
     * List existing Cluster entries, ordered by most recently updated.
     * @summary List Cluster entries
     * @param {string} name Required when creating
     * @param {string} [address] Required when creating
     * @param {string} [azureSubscription] Required when creating if providers is &#x27;azure&#x27;
     * @param {string} [base] Required when creating
     * @param {string} [createdAt] 
     * @param {string} [googleProject] Required when creating if provider is &#x27;google&#x27;
     * @param {number} [id] 
     * @param {string} [provider] 
     * @param {boolean} [requiresSuitability] 
     * @param {string} [updatedAt] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2ClustersGet(name: string, address?: string, azureSubscription?: string, base?: string, createdAt?: string, googleProject?: string, id?: number, provider?: string, requiresSuitability?: boolean, updatedAt?: string, limit?: number, options?: any) {
        return ClustersApiFp(this.configuration).apiV2ClustersGet(name, address, azureSubscription, base, createdAt, googleProject, id, provider, requiresSuitability, updatedAt, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Cluster entry. Note that some fields are immutable after creation; /edit lists mutable fields.
     * @summary Create a new Cluster entry
     * @param {V2controllersCreatableCluster} body The Cluster to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2ClustersPost(body: V2controllersCreatableCluster, options?: any) {
        return ClustersApiFp(this.configuration).apiV2ClustersPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing Cluster entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Cluster entry
     * @param {string} selector The Cluster to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2ClustersSelectorDelete(selector: string, options?: any) {
        return ClustersApiFp(this.configuration).apiV2ClustersSelectorDelete(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing Cluster entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Cluster entry
     * @param {string} selector The Cluster to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2ClustersSelectorGet(selector: string, options?: any) {
        return ClustersApiFp(this.configuration).apiV2ClustersSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Edit an existing Cluster entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Cluster entry
     * @param {V2controllersEditableCluster} body The edits to make to the Cluster
     * @param {string} selector The Cluster to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2ClustersSelectorPatch(body: V2controllersEditableCluster, selector: string, options?: any) {
        return ClustersApiFp(this.configuration).apiV2ClustersSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given Cluster selector and provide any other selectors that would match the same Cluster.
     * @summary List Cluster selectors
     * @param {string} selector The selector of the Cluster to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClustersApi
     */
    public apiV2SelectorsClustersSelectorGet(selector: string, options?: any) {
        return ClustersApiFp(this.configuration).apiV2SelectorsClustersSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * EnvironmentsApi - fetch parameter creator
 * @export
 */
export const EnvironmentsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt] 
         * @param {string} [defaultCluster] 
         * @param {string} [defaultNamespace] 
         * @param {number} [id] 
         * @param {string} [lifecycle] 
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability] 
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt] 
         * @param {string} [valuesName] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base?: string, chartReleasesFromTemplate?: boolean, createdAt?: string, defaultCluster?: string, defaultNamespace?: string, id?: number, lifecycle?: string, name?: string, owner?: string, requiresSuitability?: boolean, templateEnvironment?: string, updatedAt?: string, valuesName?: string, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/api/v2/environments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (base !== undefined) {
                localVarQueryParameter['base'] = base;
            }

            if (chartReleasesFromTemplate !== undefined) {
                localVarQueryParameter['chartReleasesFromTemplate'] = chartReleasesFromTemplate;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['createdAt'] = createdAt;
            }

            if (defaultCluster !== undefined) {
                localVarQueryParameter['defaultCluster'] = defaultCluster;
            }

            if (defaultNamespace !== undefined) {
                localVarQueryParameter['defaultNamespace'] = defaultNamespace;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (lifecycle !== undefined) {
                localVarQueryParameter['lifecycle'] = lifecycle;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (requiresSuitability !== undefined) {
                localVarQueryParameter['requiresSuitability'] = requiresSuitability;
            }

            if (templateEnvironment !== undefined) {
                localVarQueryParameter['templateEnvironment'] = templateEnvironment;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updatedAt'] = updatedAt;
            }

            if (valuesName !== undefined) {
                localVarQueryParameter['valuesName'] = valuesName;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body: V2controllersCreatableEnvironment, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2EnvironmentsPost.');
            }
            const localVarPath = `/api/v2/environments`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersCreatableEnvironment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorDelete.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorGet.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body: V2controllersEditableEnvironment, selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling apiV2EnvironmentsSelectorPatch.');
            }
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2EnvironmentsSelectorPatch.');
            }
            const localVarPath = `/api/v2/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"V2controllersEditableEnvironment" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector: string, options: any = {}): FetchArgs {
            // verify required parameter 'selector' is not null or undefined
            if (selector === null || selector === undefined) {
                throw new RequiredError('selector','Required parameter selector was null or undefined when calling apiV2SelectorsEnvironmentsSelectorGet.');
            }
            const localVarPath = `/api/v2/selectors/environments/{selector}`
                .replace(`{${"selector"}}`, encodeURIComponent(String(selector)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EnvironmentsApi - functional programming interface
 * @export
 */
export const EnvironmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt] 
         * @param {string} [defaultCluster] 
         * @param {string} [defaultNamespace] 
         * @param {number} [id] 
         * @param {string} [lifecycle] 
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability] 
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt] 
         * @param {string} [valuesName] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base?: string, chartReleasesFromTemplate?: boolean, createdAt?: string, defaultCluster?: string, defaultNamespace?: string, id?: number, lifecycle?: string, name?: string, owner?: string, requiresSuitability?: boolean, templateEnvironment?: string, updatedAt?: string, valuesName?: string, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<V2controllersEnvironment>> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body: V2controllersCreatableEnvironment, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersEnvironment> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2EnvironmentsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersEnvironment> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2EnvironmentsSelectorDelete(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersEnvironment> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2EnvironmentsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body: V2controllersEditableEnvironment, selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<V2controllersEnvironment> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2EnvironmentsSelectorPatch(body, selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = EnvironmentsApiFetchParamCreator(configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EnvironmentsApi - factory interface
 * @export
 */
export const EnvironmentsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * List existing Environment entries, ordered by most recently updated.
         * @summary List Environment entries
         * @param {string} [base] Required when creating
         * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
         * @param {string} [createdAt] 
         * @param {string} [defaultCluster] 
         * @param {string} [defaultNamespace] 
         * @param {number} [id] 
         * @param {string} [lifecycle] 
         * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
         * @param {string} [owner] When creating, will be set to your email
         * @param {boolean} [requiresSuitability] 
         * @param {string} [templateEnvironment] Required for dynamic environments
         * @param {string} [updatedAt] 
         * @param {string} [valuesName] 
         * @param {number} [limit] An optional limit to the number of entries returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsGet(base?: string, chartReleasesFromTemplate?: boolean, createdAt?: string, defaultCluster?: string, defaultNamespace?: string, id?: number, lifecycle?: string, name?: string, owner?: string, requiresSuitability?: boolean, templateEnvironment?: string, updatedAt?: string, valuesName?: string, limit?: number, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options)(fetch, basePath);
        },
        /**
         * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
         * @summary Create a new Environment entry
         * @param {V2controllersCreatableEnvironment} body The Environment to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsPost(body: V2controllersCreatableEnvironment, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2EnvironmentsPost(body, options)(fetch, basePath);
        },
        /**
         * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Delete a Environment entry
         * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorDelete(selector: string, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2EnvironmentsSelectorDelete(selector, options)(fetch, basePath);
        },
        /**
         * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
         * @summary Get a Environment entry
         * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorGet(selector: string, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2EnvironmentsSelectorGet(selector, options)(fetch, basePath);
        },
        /**
         * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
         * @summary Edit a Environment entry
         * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
         * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2EnvironmentsSelectorPatch(body: V2controllersEditableEnvironment, selector: string, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2EnvironmentsSelectorPatch(body, selector, options)(fetch, basePath);
        },
        /**
         * Validate a given Environment selector and provide any other selectors that would match the same Environment.
         * @summary List Environment selectors
         * @param {string} selector The selector of the Environment to list other selectors for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2SelectorsEnvironmentsSelectorGet(selector: string, options?: any) {
            return EnvironmentsApiFp(configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options)(fetch, basePath);
        },
    };
};

/**
 * EnvironmentsApi - object-oriented interface
 * @export
 * @class EnvironmentsApi
 * @extends {BaseAPI}
 */
export class EnvironmentsApi extends BaseAPI {
    /**
     * List existing Environment entries, ordered by most recently updated.
     * @summary List Environment entries
     * @param {string} [base] Required when creating
     * @param {boolean} [chartReleasesFromTemplate] Upon creation of a dynamic environment, if this is true the template&#x27;s chart releases will be copied to the new environment
     * @param {string} [createdAt] 
     * @param {string} [defaultCluster] 
     * @param {string} [defaultNamespace] 
     * @param {number} [id] 
     * @param {string} [lifecycle] 
     * @param {string} [name] When creating, will be calculated if dynamic, required otherwise
     * @param {string} [owner] When creating, will be set to your email
     * @param {boolean} [requiresSuitability] 
     * @param {string} [templateEnvironment] Required for dynamic environments
     * @param {string} [updatedAt] 
     * @param {string} [valuesName] 
     * @param {number} [limit] An optional limit to the number of entries returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2EnvironmentsGet(base?: string, chartReleasesFromTemplate?: boolean, createdAt?: string, defaultCluster?: string, defaultNamespace?: string, id?: number, lifecycle?: string, name?: string, owner?: string, requiresSuitability?: boolean, templateEnvironment?: string, updatedAt?: string, valuesName?: string, limit?: number, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2EnvironmentsGet(base, chartReleasesFromTemplate, createdAt, defaultCluster, defaultNamespace, id, lifecycle, name, owner, requiresSuitability, templateEnvironment, updatedAt, valuesName, limit, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new Environment entry. Note that some fields are immutable after creation; /edit lists mutable fields. Creating a dynamic environment based on a template will also copy ChartReleases from the template.
     * @summary Create a new Environment entry
     * @param {V2controllersCreatableEnvironment} body The Environment to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2EnvironmentsPost(body: V2controllersCreatableEnvironment, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2EnvironmentsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an existing Environment entry via one of its \"selectors\": name or numeric ID.
     * @summary Delete a Environment entry
     * @param {string} selector The Environment to delete&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2EnvironmentsSelectorDelete(selector: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2EnvironmentsSelectorDelete(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Get an existing Environment entry via one of its \"selectors\": name or numeric ID.
     * @summary Get a Environment entry
     * @param {string} selector The Environment to get&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2EnvironmentsSelectorGet(selector: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2EnvironmentsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

    /**
     * Edit an existing Environment entry via one of its \"selectors\": name or numeric ID. Note that only mutable fields are available here, immutable fields can only be set using /create.
     * @summary Edit a Environment entry
     * @param {V2controllersEditableEnvironment} body The edits to make to the Environment
     * @param {string} selector The Environment to edit&#x27;s selector: name or numeric ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2EnvironmentsSelectorPatch(body: V2controllersEditableEnvironment, selector: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2EnvironmentsSelectorPatch(body, selector, options)(this.fetch, this.basePath);
    }

    /**
     * Validate a given Environment selector and provide any other selectors that would match the same Environment.
     * @summary List Environment selectors
     * @param {string} selector The selector of the Environment to list other selectors for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnvironmentsApi
     */
    public apiV2SelectorsEnvironmentsSelectorGet(selector: string, options?: any) {
        return EnvironmentsApiFp(this.configuration).apiV2SelectorsEnvironmentsSelectorGet(selector, options)(this.fetch, this.basePath);
    }

}
/**
 * MiscApi - fetch parameter creator
 * @export
 */
export const MiscApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options: any = {}): FetchArgs {
            const localVarPath = `/my-user`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options: any = {}): FetchArgs {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options: any = {}): FetchArgs {
            const localVarPath = `/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiscApi - functional programming interface
 * @export
 */
export const MiscApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MiscMyUserResponse> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).myUserGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MiscStatusResponse> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).statusGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MiscVersionResponse> {
            const localVarFetchArgs = MiscApiFetchParamCreator(configuration).versionGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MiscApi - factory interface
 * @export
 */
export const MiscApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
         * @summary Get information about the calling user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        myUserGet(options?: any) {
            return MiscApiFp(configuration).myUserGet(options)(fetch, basePath);
        },
        /**
         * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
         * @summary Get Sherlock's current status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusGet(options?: any) {
            return MiscApiFp(configuration).statusGet(options)(fetch, basePath);
        },
        /**
         * Get the build version of this Sherlock instance.
         * @summary Get Sherlock's own current version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options?: any) {
            return MiscApiFp(configuration).versionGet(options)(fetch, basePath);
        },
    };
};

/**
 * MiscApi - object-oriented interface
 * @export
 * @class MiscApi
 * @extends {BaseAPI}
 */
export class MiscApi extends BaseAPI {
    /**
     * Get Sherlock's understanding of the calling user based on IAP and the Firecloud.org Google Workspace organization.
     * @summary Get information about the calling user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public myUserGet(options?: any) {
        return MiscApiFp(this.configuration).myUserGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get Sherlock's current status. Right now, this endpoint always returned OK (if the server is online). This endpoint is acceptable to use for a readiness check.
     * @summary Get Sherlock's current status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public statusGet(options?: any) {
        return MiscApiFp(this.configuration).statusGet(options)(this.fetch, this.basePath);
    }

    /**
     * Get the build version of this Sherlock instance.
     * @summary Get Sherlock's own current version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiscApi
     */
    public versionGet(options?: any) {
        return MiscApiFp(this.configuration).versionGet(options)(this.fetch, this.basePath);
    }

}
