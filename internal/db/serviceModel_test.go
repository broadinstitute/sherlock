package db

import (
	"regexp"
	"strconv"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/broadinstitute/sherlock/internal/services"
	"github.com/google/go-cmp/cmp"
)

// Used to validate sql statements generated by the orm
const (
	expectedListAllServicesQuery    string = "SELECT * FROM \"services\""
	expectedInsertServiceQueryRegEx string = "^INSERT INTO \"services\"*"
	expectedGetServiceByIDQuery     string = `SELECT * FROM "services" WHERE "services"."id" = $1 ORDER BY "services"."id" LIMIT 1`
)

// sqlmock requires all the expected column names passed as a string
// in order to simulate expected db query results
var serviceColumns []string = []string{"id", "name", "repo_url", "created_at", "updated_at"}

func TestListAllServices(t *testing.T) {
	// Set up stub db
	model, mock := NewMockServiceModel(t, false)

	cases := []struct {
		name     string
		services []services.Service
	}{
		{
			name:     "no existing services",
			services: []services.Service{},
		},
		{
			name: "one existing service",
			services: []services.Service{
				{
					ID:        1,
					Name:      "cromwell",
					RepoURL:   "https://github.com/broadinstitute/cromwell",
					CreatedAt: time.Now(),
					UpdatedAt: time.Now(),
				},
			},
		},
		{
			name: "multiple existing services",
			services: []services.Service{
				{
					ID:        1,
					Name:      "cromwell",
					RepoURL:   "https://github.com/broadinstitute/cromwell",
					CreatedAt: time.Now(),
					UpdatedAt: time.Now(),
				},
				{
					ID:        2,
					Name:      "leonardo",
					RepoURL:   "https://github.com/databiosphere/leonardo",
					CreatedAt: time.Now(),
					UpdatedAt: time.Now(),
				},
				{
					ID:        3,
					Name:      "buffer",
					RepoURL:   "https://github.com/databiosphere/buffer",
					CreatedAt: time.Now(),
					UpdatedAt: time.Now(),
				},
			},
		},
	}

	for _, testCase := range cases {
		t.Run(testCase.name, func(t *testing.T) {
			populateStubData(t, mock, testCase.services)

			services, err := model.ListAll()
			if err != nil {
				t.Errorf("received unexpected error listing servies: %v", err)
			}

			// validates all the expectations registered with the mock db are satisfied
			if err := mock.ExpectationsWereMet(); err != nil {
				t.Errorf("database operation expectations were not met: %v", err)
			}

			expectedServices := testCase.services
			if diff := cmp.Diff(services, expectedServices); diff != "" {
				t.Errorf("unexpected result listing services: %v", diff)
			}
		})
	}

}

// The purpose of this test is to validate the database operations
// generated by the orm are as expected. by the time a service object reaches this function
// it will all ready have been checked for validity by the type system and additional validation
func TestCreateService(t *testing.T) {
	model, mock := NewMockServiceModel(t, true)
	newService := &services.Service{
		Name:    "testing",
		RepoURL: "https://test.com",
	}

	// verify that the genrated sql performs the operation expected
	setCreateServiceExpectations(mock, newService.Name, newService.RepoURL)

	_, err := model.Create(newService)
	if err != nil {
		t.Errorf("unexpecting error creating service %v: %v", newService, err)
	}

	// validates all the expectations registered with the mock db are satisfied
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Errorf("database operation expectations were not met: %v", err)
	}
}

// The purpose of this test is solely to verfiy generated sql matches expectations
// The success and failure modes of this functionality are already covered in route unit
// tests and integration tests with a real postgres
func TestGetServiceByID(t *testing.T) {
	model, mock := NewMockServiceModel(t, true)

	testService := services.Service{
		Name:      "Cromwell",
		ID:        1,
		RepoURL:   "https://blah.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}

	// generate an entry in the mock service table
	expectedRow := mock.NewRows(serviceColumns)
	expectedRow.AddRow(testService.ID, testService.Name, testService.RepoURL, testService.CreatedAt, testService.UpdatedAt)

	mock.ExpectQuery(
		regexp.QuoteMeta(expectedGetServiceByIDQuery),
	).WithArgs(strconv.Itoa(testService.ID)).WillReturnRows(expectedRow)

	result, err := model.Get(strconv.Itoa(testService.ID))
	if err != nil {
		t.Errorf("encountered unexpected error getting service by id %v", err)
	}

	// validates all the expectations registered with the mock db are satisfied
	if err := mock.ExpectationsWereMet(); err != nil {
		t.Fatalf("database operation expectations were not met: %v", err)
	}

	if diff := cmp.Diff(result, &testService); diff != "" {
		t.Errorf("received unexpected result: %v", diff)
	}
}

func populateStubData(t *testing.T, mock sqlmock.Sqlmock, expectedData []services.Service) {
	t.Helper()

	// setup expected table schema in stub
	expectedRows := mock.NewRows(serviceColumns)
	for _, entry := range expectedData {
		expectedRows.AddRow(entry.ID, entry.Name, entry.RepoURL, entry.CreatedAt, entry.UpdatedAt)
	}
	mock.ExpectQuery(
		expectedListAllServicesQuery,
	).WillReturnRows(expectedRows)
}

func setCreateServiceExpectations(mock sqlmock.Sqlmock, name, repoURL string) {
	// This function defines expectations for the database transaction to create a new service.
	mock.ExpectBegin()
	mock.ExpectQuery(expectedInsertServiceQueryRegEx).
		// The AnyArgs are place holders for the auto-generated timestamp arguments
		WithArgs(name, repoURL, sqlmock.AnyArg(), sqlmock.AnyArg()).
		WillReturnRows(sqlmock.NewRows([]string{"id"}).AddRow(1))
	mock.ExpectCommit()
}
