/* tslint:disable */
/* eslint-disable */
/**
 * Sherlock
 * The Data Science Platform\'s source-of-truth service. Note: this API will try to load and return associations in responses, so clients won\'t need to make as many requests. This behavior isn\'t recursive, though, so associations of associations are *not* fully loaded (even if it might seem that way from looking at the data types).
 *
 * The version of the OpenAPI document: development
 * Contact: dsp-devops@broadinstitute.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ErrorsErrorResponse,
  SherlockCiRunV3,
  SherlockCiRunV3Upsert,
} from '../models/index';
import {
    ErrorsErrorResponseFromJSON,
    ErrorsErrorResponseToJSON,
    SherlockCiRunV3FromJSON,
    SherlockCiRunV3ToJSON,
    SherlockCiRunV3UpsertFromJSON,
    SherlockCiRunV3UpsertToJSON,
} from '../models/index';

export interface ApiCiRunsV3GetRequest {
    argoWorkflowsName?: string;
    argoWorkflowsNamespace?: string;
    argoWorkflowsTemplate?: string;
    createdAt?: Date;
    githubActionsAttemptNumber?: number;
    githubActionsOwner?: string;
    githubActionsRepo?: string;
    githubActionsRunID?: number;
    githubActionsWorkflowPath?: string;
    id?: number;
    notifySlackChannelsUponFailure?: Array<string>;
    notifySlackChannelsUponRetry?: Array<string>;
    notifySlackChannelsUponSuccess?: Array<string>;
    notifySlackCustomIcon?: string;
    platform?: string;
    resourceStatus?: string;
    startedAt?: string;
    status?: string;
    terminalAt?: string;
    terminationHooksDispatchedAt?: Date;
    updatedAt?: Date;
    limit?: number;
    offset?: number;
}

export interface ApiCiRunsV3PutRequest {
    ciRun: SherlockCiRunV3Upsert;
}

export interface ApiCiRunsV3SelectorGetRequest {
    selector: string;
}

/**
 * 
 */
export class CiRunsApi extends runtime.BaseAPI {

    /**
     * List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days. This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed here can probably successfully called by a GitHub Actions deploy hook.
     * List GitHub info gleaned from CiRuns
     */
    async apiCiRunsProceduresV3GithubInfoGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: { [key: string]: Array<string>; }; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/ci-runs/procedures/v3/github-info`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days. This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed here can probably successfully called by a GitHub Actions deploy hook.
     * List GitHub info gleaned from CiRuns
     */
    async apiCiRunsProceduresV3GithubInfoGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: { [key: string]: Array<string>; }; }> {
        const response = await this.apiCiRunsProceduresV3GithubInfoGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources. Results are ordered by start time, starting at most recent.
     * List CiRuns matching a filter
     */
    async apiCiRunsV3GetRaw(requestParameters: ApiCiRunsV3GetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SherlockCiRunV3>>> {
        const queryParameters: any = {};

        if (requestParameters['argoWorkflowsName'] != null) {
            queryParameters['argoWorkflowsName'] = requestParameters['argoWorkflowsName'];
        }

        if (requestParameters['argoWorkflowsNamespace'] != null) {
            queryParameters['argoWorkflowsNamespace'] = requestParameters['argoWorkflowsNamespace'];
        }

        if (requestParameters['argoWorkflowsTemplate'] != null) {
            queryParameters['argoWorkflowsTemplate'] = requestParameters['argoWorkflowsTemplate'];
        }

        if (requestParameters['createdAt'] != null) {
            queryParameters['createdAt'] = (requestParameters['createdAt'] as any).toISOString();
        }

        if (requestParameters['githubActionsAttemptNumber'] != null) {
            queryParameters['githubActionsAttemptNumber'] = requestParameters['githubActionsAttemptNumber'];
        }

        if (requestParameters['githubActionsOwner'] != null) {
            queryParameters['githubActionsOwner'] = requestParameters['githubActionsOwner'];
        }

        if (requestParameters['githubActionsRepo'] != null) {
            queryParameters['githubActionsRepo'] = requestParameters['githubActionsRepo'];
        }

        if (requestParameters['githubActionsRunID'] != null) {
            queryParameters['githubActionsRunID'] = requestParameters['githubActionsRunID'];
        }

        if (requestParameters['githubActionsWorkflowPath'] != null) {
            queryParameters['githubActionsWorkflowPath'] = requestParameters['githubActionsWorkflowPath'];
        }

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        if (requestParameters['notifySlackChannelsUponFailure'] != null) {
            queryParameters['notifySlackChannelsUponFailure'] = requestParameters['notifySlackChannelsUponFailure']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['notifySlackChannelsUponRetry'] != null) {
            queryParameters['notifySlackChannelsUponRetry'] = requestParameters['notifySlackChannelsUponRetry']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['notifySlackChannelsUponSuccess'] != null) {
            queryParameters['notifySlackChannelsUponSuccess'] = requestParameters['notifySlackChannelsUponSuccess']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['notifySlackCustomIcon'] != null) {
            queryParameters['notifySlackCustomIcon'] = requestParameters['notifySlackCustomIcon'];
        }

        if (requestParameters['platform'] != null) {
            queryParameters['platform'] = requestParameters['platform'];
        }

        if (requestParameters['resourceStatus'] != null) {
            queryParameters['resourceStatus'] = requestParameters['resourceStatus'];
        }

        if (requestParameters['startedAt'] != null) {
            queryParameters['startedAt'] = requestParameters['startedAt'];
        }

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['terminalAt'] != null) {
            queryParameters['terminalAt'] = requestParameters['terminalAt'];
        }

        if (requestParameters['terminationHooksDispatchedAt'] != null) {
            queryParameters['terminationHooksDispatchedAt'] = (requestParameters['terminationHooksDispatchedAt'] as any).toISOString();
        }

        if (requestParameters['updatedAt'] != null) {
            queryParameters['updatedAt'] = (requestParameters['updatedAt'] as any).toISOString();
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/ci-runs/v3`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SherlockCiRunV3FromJSON));
    }

    /**
     * List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources. Results are ordered by start time, starting at most recent.
     * List CiRuns matching a filter
     */
    async apiCiRunsV3Get(requestParameters: ApiCiRunsV3GetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SherlockCiRunV3>> {
        const response = await this.apiCiRunsV3GetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent. The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will be smart about \"spreading\" to indirect relations. More info is available on the CiRunV3Upsert data type, but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions), specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster implies all chart releases they contain.
     * Create or update a CiRun
     */
    async apiCiRunsV3PutRaw(requestParameters: ApiCiRunsV3PutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SherlockCiRunV3>> {
        if (requestParameters['ciRun'] == null) {
            throw new runtime.RequiredError(
                'ciRun',
                'Required parameter "ciRun" was null or undefined when calling apiCiRunsV3Put().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';


        let urlPath = `/api/ci-runs/v3`;

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SherlockCiRunV3UpsertToJSON(requestParameters['ciRun']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SherlockCiRunV3FromJSON(jsonValue));
    }

    /**
     * Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent. The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will be smart about \"spreading\" to indirect relations. More info is available on the CiRunV3Upsert data type, but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions), specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster implies all chart releases they contain.
     * Create or update a CiRun
     */
    async apiCiRunsV3Put(requestParameters: ApiCiRunsV3PutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SherlockCiRunV3> {
        const response = await this.apiCiRunsV3PutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a CiRun, including CiIdentifiers representing related resources or resources it affected.
     * Get a CiRun, including CiIdentifiers for related resources
     */
    async apiCiRunsV3SelectorGetRaw(requestParameters: ApiCiRunsV3SelectorGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SherlockCiRunV3>> {
        if (requestParameters['selector'] == null) {
            throw new runtime.RequiredError(
                'selector',
                'Required parameter "selector" was null or undefined when calling apiCiRunsV3SelectorGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};


        let urlPath = `/api/ci-runs/v3/{selector}`;
        urlPath = urlPath.replace(`{${"selector"}}`, encodeURIComponent(String(requestParameters['selector'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SherlockCiRunV3FromJSON(jsonValue));
    }

    /**
     * Get a CiRun, including CiIdentifiers representing related resources or resources it affected.
     * Get a CiRun, including CiIdentifiers for related resources
     */
    async apiCiRunsV3SelectorGet(requestParameters: ApiCiRunsV3SelectorGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SherlockCiRunV3> {
        const response = await this.apiCiRunsV3SelectorGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
