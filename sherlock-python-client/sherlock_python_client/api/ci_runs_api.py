# coding: utf-8

"""
    Sherlock

    The Data Science Platform's source-of-truth service. Note: this API will try to load and return associations in responses, so clients won't need to make as many requests. This behavior isn't recursive, though, so associations of associations are *not* fully loaded (even if it might seem that way from looking at the data types).

    The version of the OpenAPI document: development
    Contact: dsp-devops@broadinstitute.org
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictInt, StrictStr
from typing import Dict, List, Optional
from typing_extensions import Annotated
from sherlock_python_client.models.sherlock_ci_run_v3 import SherlockCiRunV3
from sherlock_python_client.models.sherlock_ci_run_v3_upsert import SherlockCiRunV3Upsert

from sherlock_python_client.api_client import ApiClient, RequestSerialized
from sherlock_python_client.api_response import ApiResponse
from sherlock_python_client.rest import RESTResponseType


class CiRunsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def api_ci_runs_procedures_v3_github_info_get(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Dict[str, Dict[str, List[str]]]:
        """List GitHub info gleaned from CiRuns

        List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days. This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed here can probably successfully called by a GitHub Actions deploy hook.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_procedures_v3_github_info_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, Dict[str, List[str]]]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_ci_runs_procedures_v3_github_info_get_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Dict[str, Dict[str, List[str]]]]:
        """List GitHub info gleaned from CiRuns

        List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days. This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed here can probably successfully called by a GitHub Actions deploy hook.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_procedures_v3_github_info_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, Dict[str, List[str]]]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_ci_runs_procedures_v3_github_info_get_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List GitHub info gleaned from CiRuns

        List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days. This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed here can probably successfully called by a GitHub Actions deploy hook.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_procedures_v3_github_info_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Dict[str, Dict[str, List[str]]]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_ci_runs_procedures_v3_github_info_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ci-runs/procedures/v3/github-info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_ci_runs_v3_get(
        self,
        argo_workflows_name: Optional[StrictStr] = None,
        argo_workflows_namespace: Optional[StrictStr] = None,
        argo_workflows_template: Optional[StrictStr] = None,
        created_at: Optional[datetime] = None,
        github_actions_attempt_number: Optional[StrictInt] = None,
        github_actions_owner: Optional[StrictStr] = None,
        github_actions_repo: Optional[StrictStr] = None,
        github_actions_run_id: Optional[StrictInt] = None,
        github_actions_workflow_path: Optional[StrictStr] = None,
        id: Optional[StrictInt] = None,
        notify_slack_channels_upon_failure: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun fails. This field is always appended to when mutated.")] = None,
        notify_slack_channels_upon_retry: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.")] = None,
        notify_slack_channels_upon_success: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.")] = None,
        notify_slack_custom_icon: Annotated[Optional[StrictStr], Field(description="Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).")] = None,
        platform: Optional[StrictStr] = None,
        resource_status: Annotated[Optional[StrictStr], Field(description="Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource")] = None,
        started_at: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        terminal_at: Optional[StrictStr] = None,
        termination_hooks_dispatched_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Control how many CiRuns are returned (default 100)")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Control the offset for the returned CiRuns (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SherlockCiRunV3]:
        """List CiRuns matching a filter

        List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources. Results are ordered by start time, starting at most recent.

        :param argo_workflows_name:
        :type argo_workflows_name: str
        :param argo_workflows_namespace:
        :type argo_workflows_namespace: str
        :param argo_workflows_template:
        :type argo_workflows_template: str
        :param created_at:
        :type created_at: datetime
        :param github_actions_attempt_number:
        :type github_actions_attempt_number: int
        :param github_actions_owner:
        :type github_actions_owner: str
        :param github_actions_repo:
        :type github_actions_repo: str
        :param github_actions_run_id:
        :type github_actions_run_id: int
        :param github_actions_workflow_path:
        :type github_actions_workflow_path: str
        :param id:
        :type id: int
        :param notify_slack_channels_upon_failure: Slack channels to notify if this CiRun fails. This field is always appended to when mutated.
        :type notify_slack_channels_upon_failure: List[str]
        :param notify_slack_channels_upon_retry: Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.
        :type notify_slack_channels_upon_retry: List[str]
        :param notify_slack_channels_upon_success: Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.
        :type notify_slack_channels_upon_success: List[str]
        :param notify_slack_custom_icon: Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).
        :type notify_slack_custom_icon: str
        :param platform:
        :type platform: str
        :param resource_status: Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource
        :type resource_status: str
        :param started_at:
        :type started_at: str
        :param status:
        :type status: str
        :param terminal_at:
        :type terminal_at: str
        :param termination_hooks_dispatched_at:
        :type termination_hooks_dispatched_at: datetime
        :param updated_at:
        :type updated_at: datetime
        :param limit: Control how many CiRuns are returned (default 100)
        :type limit: int
        :param offset: Control the offset for the returned CiRuns (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_get_serialize(
            argo_workflows_name=argo_workflows_name,
            argo_workflows_namespace=argo_workflows_namespace,
            argo_workflows_template=argo_workflows_template,
            created_at=created_at,
            github_actions_attempt_number=github_actions_attempt_number,
            github_actions_owner=github_actions_owner,
            github_actions_repo=github_actions_repo,
            github_actions_run_id=github_actions_run_id,
            github_actions_workflow_path=github_actions_workflow_path,
            id=id,
            notify_slack_channels_upon_failure=notify_slack_channels_upon_failure,
            notify_slack_channels_upon_retry=notify_slack_channels_upon_retry,
            notify_slack_channels_upon_success=notify_slack_channels_upon_success,
            notify_slack_custom_icon=notify_slack_custom_icon,
            platform=platform,
            resource_status=resource_status,
            started_at=started_at,
            status=status,
            terminal_at=terminal_at,
            termination_hooks_dispatched_at=termination_hooks_dispatched_at,
            updated_at=updated_at,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SherlockCiRunV3]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_ci_runs_v3_get_with_http_info(
        self,
        argo_workflows_name: Optional[StrictStr] = None,
        argo_workflows_namespace: Optional[StrictStr] = None,
        argo_workflows_template: Optional[StrictStr] = None,
        created_at: Optional[datetime] = None,
        github_actions_attempt_number: Optional[StrictInt] = None,
        github_actions_owner: Optional[StrictStr] = None,
        github_actions_repo: Optional[StrictStr] = None,
        github_actions_run_id: Optional[StrictInt] = None,
        github_actions_workflow_path: Optional[StrictStr] = None,
        id: Optional[StrictInt] = None,
        notify_slack_channels_upon_failure: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun fails. This field is always appended to when mutated.")] = None,
        notify_slack_channels_upon_retry: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.")] = None,
        notify_slack_channels_upon_success: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.")] = None,
        notify_slack_custom_icon: Annotated[Optional[StrictStr], Field(description="Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).")] = None,
        platform: Optional[StrictStr] = None,
        resource_status: Annotated[Optional[StrictStr], Field(description="Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource")] = None,
        started_at: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        terminal_at: Optional[StrictStr] = None,
        termination_hooks_dispatched_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Control how many CiRuns are returned (default 100)")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Control the offset for the returned CiRuns (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SherlockCiRunV3]]:
        """List CiRuns matching a filter

        List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources. Results are ordered by start time, starting at most recent.

        :param argo_workflows_name:
        :type argo_workflows_name: str
        :param argo_workflows_namespace:
        :type argo_workflows_namespace: str
        :param argo_workflows_template:
        :type argo_workflows_template: str
        :param created_at:
        :type created_at: datetime
        :param github_actions_attempt_number:
        :type github_actions_attempt_number: int
        :param github_actions_owner:
        :type github_actions_owner: str
        :param github_actions_repo:
        :type github_actions_repo: str
        :param github_actions_run_id:
        :type github_actions_run_id: int
        :param github_actions_workflow_path:
        :type github_actions_workflow_path: str
        :param id:
        :type id: int
        :param notify_slack_channels_upon_failure: Slack channels to notify if this CiRun fails. This field is always appended to when mutated.
        :type notify_slack_channels_upon_failure: List[str]
        :param notify_slack_channels_upon_retry: Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.
        :type notify_slack_channels_upon_retry: List[str]
        :param notify_slack_channels_upon_success: Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.
        :type notify_slack_channels_upon_success: List[str]
        :param notify_slack_custom_icon: Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).
        :type notify_slack_custom_icon: str
        :param platform:
        :type platform: str
        :param resource_status: Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource
        :type resource_status: str
        :param started_at:
        :type started_at: str
        :param status:
        :type status: str
        :param terminal_at:
        :type terminal_at: str
        :param termination_hooks_dispatched_at:
        :type termination_hooks_dispatched_at: datetime
        :param updated_at:
        :type updated_at: datetime
        :param limit: Control how many CiRuns are returned (default 100)
        :type limit: int
        :param offset: Control the offset for the returned CiRuns (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_get_serialize(
            argo_workflows_name=argo_workflows_name,
            argo_workflows_namespace=argo_workflows_namespace,
            argo_workflows_template=argo_workflows_template,
            created_at=created_at,
            github_actions_attempt_number=github_actions_attempt_number,
            github_actions_owner=github_actions_owner,
            github_actions_repo=github_actions_repo,
            github_actions_run_id=github_actions_run_id,
            github_actions_workflow_path=github_actions_workflow_path,
            id=id,
            notify_slack_channels_upon_failure=notify_slack_channels_upon_failure,
            notify_slack_channels_upon_retry=notify_slack_channels_upon_retry,
            notify_slack_channels_upon_success=notify_slack_channels_upon_success,
            notify_slack_custom_icon=notify_slack_custom_icon,
            platform=platform,
            resource_status=resource_status,
            started_at=started_at,
            status=status,
            terminal_at=terminal_at,
            termination_hooks_dispatched_at=termination_hooks_dispatched_at,
            updated_at=updated_at,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SherlockCiRunV3]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_ci_runs_v3_get_without_preload_content(
        self,
        argo_workflows_name: Optional[StrictStr] = None,
        argo_workflows_namespace: Optional[StrictStr] = None,
        argo_workflows_template: Optional[StrictStr] = None,
        created_at: Optional[datetime] = None,
        github_actions_attempt_number: Optional[StrictInt] = None,
        github_actions_owner: Optional[StrictStr] = None,
        github_actions_repo: Optional[StrictStr] = None,
        github_actions_run_id: Optional[StrictInt] = None,
        github_actions_workflow_path: Optional[StrictStr] = None,
        id: Optional[StrictInt] = None,
        notify_slack_channels_upon_failure: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun fails. This field is always appended to when mutated.")] = None,
        notify_slack_channels_upon_retry: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.")] = None,
        notify_slack_channels_upon_success: Annotated[Optional[List[StrictStr]], Field(description="Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.")] = None,
        notify_slack_custom_icon: Annotated[Optional[StrictStr], Field(description="Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).")] = None,
        platform: Optional[StrictStr] = None,
        resource_status: Annotated[Optional[StrictStr], Field(description="Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource")] = None,
        started_at: Optional[StrictStr] = None,
        status: Optional[StrictStr] = None,
        terminal_at: Optional[StrictStr] = None,
        termination_hooks_dispatched_at: Optional[datetime] = None,
        updated_at: Optional[datetime] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Control how many CiRuns are returned (default 100)")] = None,
        offset: Annotated[Optional[StrictInt], Field(description="Control the offset for the returned CiRuns (default 0)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List CiRuns matching a filter

        List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources. Results are ordered by start time, starting at most recent.

        :param argo_workflows_name:
        :type argo_workflows_name: str
        :param argo_workflows_namespace:
        :type argo_workflows_namespace: str
        :param argo_workflows_template:
        :type argo_workflows_template: str
        :param created_at:
        :type created_at: datetime
        :param github_actions_attempt_number:
        :type github_actions_attempt_number: int
        :param github_actions_owner:
        :type github_actions_owner: str
        :param github_actions_repo:
        :type github_actions_repo: str
        :param github_actions_run_id:
        :type github_actions_run_id: int
        :param github_actions_workflow_path:
        :type github_actions_workflow_path: str
        :param id:
        :type id: int
        :param notify_slack_channels_upon_failure: Slack channels to notify if this CiRun fails. This field is always appended to when mutated.
        :type notify_slack_channels_upon_failure: List[str]
        :param notify_slack_channels_upon_retry: Slack channels to notify if this CiRun is retried. This field is always appended to when mutated. It will de-dupe with the other notify fields.
        :type notify_slack_channels_upon_retry: List[str]
        :param notify_slack_channels_upon_success: Slack channels to notify if this CiRun succeeds. This field is always appended to when mutated.
        :type notify_slack_channels_upon_success: List[str]
        :param notify_slack_custom_icon: Icon to use for success or failure Slack notifications. Can be given either as a URL to an image or as a Slack emoji (using colon shortcodes, like :smiley:). An empty string is ignored to facilitate calling from GitHub Actions (where it's easier to pass an empty string than not send the field at all).
        :type notify_slack_custom_icon: str
        :param platform:
        :type platform: str
        :param resource_status: Available only when querying a CiRun via a CiIdentifier, indicates the status of the run for that resource
        :type resource_status: str
        :param started_at:
        :type started_at: str
        :param status:
        :type status: str
        :param terminal_at:
        :type terminal_at: str
        :param termination_hooks_dispatched_at:
        :type termination_hooks_dispatched_at: datetime
        :param updated_at:
        :type updated_at: datetime
        :param limit: Control how many CiRuns are returned (default 100)
        :type limit: int
        :param offset: Control the offset for the returned CiRuns (default 0)
        :type offset: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_get_serialize(
            argo_workflows_name=argo_workflows_name,
            argo_workflows_namespace=argo_workflows_namespace,
            argo_workflows_template=argo_workflows_template,
            created_at=created_at,
            github_actions_attempt_number=github_actions_attempt_number,
            github_actions_owner=github_actions_owner,
            github_actions_repo=github_actions_repo,
            github_actions_run_id=github_actions_run_id,
            github_actions_workflow_path=github_actions_workflow_path,
            id=id,
            notify_slack_channels_upon_failure=notify_slack_channels_upon_failure,
            notify_slack_channels_upon_retry=notify_slack_channels_upon_retry,
            notify_slack_channels_upon_success=notify_slack_channels_upon_success,
            notify_slack_custom_icon=notify_slack_custom_icon,
            platform=platform,
            resource_status=resource_status,
            started_at=started_at,
            status=status,
            terminal_at=terminal_at,
            termination_hooks_dispatched_at=termination_hooks_dispatched_at,
            updated_at=updated_at,
            limit=limit,
            offset=offset,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SherlockCiRunV3]",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_ci_runs_v3_get_serialize(
        self,
        argo_workflows_name,
        argo_workflows_namespace,
        argo_workflows_template,
        created_at,
        github_actions_attempt_number,
        github_actions_owner,
        github_actions_repo,
        github_actions_run_id,
        github_actions_workflow_path,
        id,
        notify_slack_channels_upon_failure,
        notify_slack_channels_upon_retry,
        notify_slack_channels_upon_success,
        notify_slack_custom_icon,
        platform,
        resource_status,
        started_at,
        status,
        terminal_at,
        termination_hooks_dispatched_at,
        updated_at,
        limit,
        offset,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'notifySlackChannelsUponFailure': 'csv',
            'notifySlackChannelsUponRetry': 'csv',
            'notifySlackChannelsUponSuccess': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if argo_workflows_name is not None:
            
            _query_params.append(('argoWorkflowsName', argo_workflows_name))
            
        if argo_workflows_namespace is not None:
            
            _query_params.append(('argoWorkflowsNamespace', argo_workflows_namespace))
            
        if argo_workflows_template is not None:
            
            _query_params.append(('argoWorkflowsTemplate', argo_workflows_template))
            
        if created_at is not None:
            if isinstance(created_at, datetime):
                _query_params.append(
                    (
                        'createdAt',
                        created_at.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('createdAt', created_at))
            
        if github_actions_attempt_number is not None:
            
            _query_params.append(('githubActionsAttemptNumber', github_actions_attempt_number))
            
        if github_actions_owner is not None:
            
            _query_params.append(('githubActionsOwner', github_actions_owner))
            
        if github_actions_repo is not None:
            
            _query_params.append(('githubActionsRepo', github_actions_repo))
            
        if github_actions_run_id is not None:
            
            _query_params.append(('githubActionsRunID', github_actions_run_id))
            
        if github_actions_workflow_path is not None:
            
            _query_params.append(('githubActionsWorkflowPath', github_actions_workflow_path))
            
        if id is not None:
            
            _query_params.append(('id', id))
            
        if notify_slack_channels_upon_failure is not None:
            
            _query_params.append(('notifySlackChannelsUponFailure', notify_slack_channels_upon_failure))
            
        if notify_slack_channels_upon_retry is not None:
            
            _query_params.append(('notifySlackChannelsUponRetry', notify_slack_channels_upon_retry))
            
        if notify_slack_channels_upon_success is not None:
            
            _query_params.append(('notifySlackChannelsUponSuccess', notify_slack_channels_upon_success))
            
        if notify_slack_custom_icon is not None:
            
            _query_params.append(('notifySlackCustomIcon', notify_slack_custom_icon))
            
        if platform is not None:
            
            _query_params.append(('platform', platform))
            
        if resource_status is not None:
            
            _query_params.append(('resourceStatus', resource_status))
            
        if started_at is not None:
            
            _query_params.append(('startedAt', started_at))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if terminal_at is not None:
            
            _query_params.append(('terminalAt', terminal_at))
            
        if termination_hooks_dispatched_at is not None:
            if isinstance(termination_hooks_dispatched_at, datetime):
                _query_params.append(
                    (
                        'terminationHooksDispatchedAt',
                        termination_hooks_dispatched_at.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('terminationHooksDispatchedAt', termination_hooks_dispatched_at))
            
        if updated_at is not None:
            if isinstance(updated_at, datetime):
                _query_params.append(
                    (
                        'updatedAt',
                        updated_at.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('updatedAt', updated_at))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ci-runs/v3',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_ci_runs_v3_put(
        self,
        ci_run: Annotated[SherlockCiRunV3Upsert, Field(description="The CiRun to upsert")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SherlockCiRunV3:
        """Create or update a CiRun

        Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent. The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will be smart about \"spreading\" to indirect relations. More info is available on the CiRunV3Upsert data type, but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions), specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster implies all chart releases they contain.

        :param ci_run: The CiRun to upsert (required)
        :type ci_run: SherlockCiRunV3Upsert
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_put_serialize(
            ci_run=ci_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_ci_runs_v3_put_with_http_info(
        self,
        ci_run: Annotated[SherlockCiRunV3Upsert, Field(description="The CiRun to upsert")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SherlockCiRunV3]:
        """Create or update a CiRun

        Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent. The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will be smart about \"spreading\" to indirect relations. More info is available on the CiRunV3Upsert data type, but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions), specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster implies all chart releases they contain.

        :param ci_run: The CiRun to upsert (required)
        :type ci_run: SherlockCiRunV3Upsert
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_put_serialize(
            ci_run=ci_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_ci_runs_v3_put_without_preload_content(
        self,
        ci_run: Annotated[SherlockCiRunV3Upsert, Field(description="The CiRun to upsert")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update a CiRun

        Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent. The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will be smart about \"spreading\" to indirect relations. More info is available on the CiRunV3Upsert data type, but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions), specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster implies all chart releases they contain.

        :param ci_run: The CiRun to upsert (required)
        :type ci_run: SherlockCiRunV3Upsert
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_put_serialize(
            ci_run=ci_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '201': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_ci_runs_v3_put_serialize(
        self,
        ci_run,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if ci_run is not None:
            _body_params = ci_run


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'application/json'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='PUT',
            resource_path='/api/ci-runs/v3',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def api_ci_runs_v3_selector_get(
        self,
        selector: Annotated[StrictStr, Field(description="The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SherlockCiRunV3:
        """Get a CiRun, including CiIdentifiers for related resources

        Get a CiRun, including CiIdentifiers representing related resources or resources it affected.

        :param selector: The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}' (required)
        :type selector: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_selector_get_serialize(
            selector=selector,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_ci_runs_v3_selector_get_with_http_info(
        self,
        selector: Annotated[StrictStr, Field(description="The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SherlockCiRunV3]:
        """Get a CiRun, including CiIdentifiers for related resources

        Get a CiRun, including CiIdentifiers representing related resources or resources it affected.

        :param selector: The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}' (required)
        :type selector: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_selector_get_serialize(
            selector=selector,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_ci_runs_v3_selector_get_without_preload_content(
        self,
        selector: Annotated[StrictStr, Field(description="The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}'")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get a CiRun, including CiIdentifiers for related resources

        Get a CiRun, including CiIdentifiers representing related resources or resources it affected.

        :param selector: The selector of the CiRun, which can be either its numeric ID, 'github-actions/{owner}/{repo}/{run ID}/{attempt}', or 'argo-workflows/{namespace}/{name}' (required)
        :type selector: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_ci_runs_v3_selector_get_serialize(
            selector=selector,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SherlockCiRunV3",
            '400': "ErrorsErrorResponse",
            '403': "ErrorsErrorResponse",
            '404': "ErrorsErrorResponse",
            '407': "ErrorsErrorResponse",
            '409': "ErrorsErrorResponse",
            '500': "ErrorsErrorResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_ci_runs_v3_selector_get_serialize(
        self,
        selector,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if selector is not None:
            _path_params['selector'] = selector
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/ci-runs/v3/{selector}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


