// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// SherlockChangesetV3 sherlock changeset v3
//
// swagger:model sherlock.ChangesetV3
type SherlockChangesetV3 struct {

	// applied at
	// Format: date-time
	AppliedAt strfmt.DateTime `json:"appliedAt,omitempty"`

	// applied by
	AppliedBy string `json:"appliedBy,omitempty"`

	// applied by info
	AppliedByInfo *SherlockUserV3 `json:"appliedByInfo,omitempty"`

	// chart release
	ChartRelease string `json:"chartRelease,omitempty"`

	// chart release info
	ChartReleaseInfo *SherlockChartReleaseV3 `json:"chartReleaseInfo,omitempty"`

	// ci identifier
	CiIdentifier *SherlockCiIdentifierV3 `json:"ciIdentifier,omitempty"`

	// created at
	// Format: date-time
	CreatedAt strfmt.DateTime `json:"createdAt,omitempty"`

	// from app version branch
	FromAppVersionBranch string `json:"fromAppVersionBranch,omitempty"`

	// from app version commit
	FromAppVersionCommit string `json:"fromAppVersionCommit,omitempty"`

	// from app version exact
	FromAppVersionExact string `json:"fromAppVersionExact,omitempty"`

	// from app version follow chart release
	FromAppVersionFollowChartRelease string `json:"fromAppVersionFollowChartRelease,omitempty"`

	// from app version reference
	FromAppVersionReference string `json:"fromAppVersionReference,omitempty"`

	// from app version resolver
	FromAppVersionResolver string `json:"fromAppVersionResolver,omitempty"`

	// from chart version exact
	FromChartVersionExact string `json:"fromChartVersionExact,omitempty"`

	// from chart version follow chart release
	FromChartVersionFollowChartRelease string `json:"fromChartVersionFollowChartRelease,omitempty"`

	// from chart version reference
	FromChartVersionReference string `json:"fromChartVersionReference,omitempty"`

	// from chart version resolver
	FromChartVersionResolver string `json:"fromChartVersionResolver,omitempty"`

	// from helmfile ref
	FromHelmfileRef string `json:"fromHelmfileRef,omitempty"`

	// from helmfile ref enabled
	FromHelmfileRefEnabled bool `json:"fromHelmfileRefEnabled,omitempty"`

	// from resolved at
	// Format: date-time
	FromResolvedAt strfmt.DateTime `json:"fromResolvedAt,omitempty"`

	// id
	ID int64 `json:"id,omitempty"`

	// new app versions
	NewAppVersions []*SherlockAppVersionV3 `json:"newAppVersions"`

	// new chart versions
	NewChartVersions []*SherlockChartVersionV3 `json:"newChartVersions"`

	// planned by
	PlannedBy string `json:"plannedBy,omitempty"`

	// planned by info
	PlannedByInfo *SherlockUserV3 `json:"plannedByInfo,omitempty"`

	// superseded at
	// Format: date-time
	SupersededAt strfmt.DateTime `json:"supersededAt,omitempty"`

	// to app version branch
	ToAppVersionBranch string `json:"toAppVersionBranch,omitempty"`

	// to app version commit
	ToAppVersionCommit string `json:"toAppVersionCommit,omitempty"`

	// to app version exact
	ToAppVersionExact string `json:"toAppVersionExact,omitempty"`

	// to app version follow chart release
	ToAppVersionFollowChartRelease string `json:"toAppVersionFollowChartRelease,omitempty"`

	// to app version reference
	ToAppVersionReference string `json:"toAppVersionReference,omitempty"`

	// to app version resolver
	ToAppVersionResolver string `json:"toAppVersionResolver,omitempty"`

	// to chart version exact
	ToChartVersionExact string `json:"toChartVersionExact,omitempty"`

	// to chart version follow chart release
	ToChartVersionFollowChartRelease string `json:"toChartVersionFollowChartRelease,omitempty"`

	// to chart version reference
	ToChartVersionReference string `json:"toChartVersionReference,omitempty"`

	// to chart version resolver
	ToChartVersionResolver string `json:"toChartVersionResolver,omitempty"`

	// to helmfile ref
	ToHelmfileRef string `json:"toHelmfileRef,omitempty"`

	// to helmfile ref enabled
	ToHelmfileRefEnabled bool `json:"toHelmfileRefEnabled,omitempty"`

	// to resolved at
	// Format: date-time
	ToResolvedAt strfmt.DateTime `json:"toResolvedAt,omitempty"`

	// updated at
	// Format: date-time
	UpdatedAt strfmt.DateTime `json:"updatedAt,omitempty"`
}

// Validate validates this sherlock changeset v3
func (m *SherlockChangesetV3) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAppliedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppliedByInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateChartReleaseInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCiIdentifier(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreatedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateFromResolvedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewAppVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNewChartVersions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePlannedByInfo(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSupersededAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToResolvedAt(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdatedAt(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SherlockChangesetV3) validateAppliedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.AppliedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("appliedAt", "body", "date-time", m.AppliedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SherlockChangesetV3) validateAppliedByInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.AppliedByInfo) { // not required
		return nil
	}

	if m.AppliedByInfo != nil {
		if err := m.AppliedByInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appliedByInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appliedByInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) validateChartReleaseInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.ChartReleaseInfo) { // not required
		return nil
	}

	if m.ChartReleaseInfo != nil {
		if err := m.ChartReleaseInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chartReleaseInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("chartReleaseInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) validateCiIdentifier(formats strfmt.Registry) error {
	if swag.IsZero(m.CiIdentifier) { // not required
		return nil
	}

	if m.CiIdentifier != nil {
		if err := m.CiIdentifier.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ciIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ciIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) validateCreatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.CreatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SherlockChangesetV3) validateFromResolvedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.FromResolvedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("fromResolvedAt", "body", "date-time", m.FromResolvedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SherlockChangesetV3) validateNewAppVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.NewAppVersions) { // not required
		return nil
	}

	for i := 0; i < len(m.NewAppVersions); i++ {
		if swag.IsZero(m.NewAppVersions[i]) { // not required
			continue
		}

		if m.NewAppVersions[i] != nil {
			if err := m.NewAppVersions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("newAppVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("newAppVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SherlockChangesetV3) validateNewChartVersions(formats strfmt.Registry) error {
	if swag.IsZero(m.NewChartVersions) { // not required
		return nil
	}

	for i := 0; i < len(m.NewChartVersions); i++ {
		if swag.IsZero(m.NewChartVersions[i]) { // not required
			continue
		}

		if m.NewChartVersions[i] != nil {
			if err := m.NewChartVersions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("newChartVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("newChartVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SherlockChangesetV3) validatePlannedByInfo(formats strfmt.Registry) error {
	if swag.IsZero(m.PlannedByInfo) { // not required
		return nil
	}

	if m.PlannedByInfo != nil {
		if err := m.PlannedByInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plannedByInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plannedByInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) validateSupersededAt(formats strfmt.Registry) error {
	if swag.IsZero(m.SupersededAt) { // not required
		return nil
	}

	if err := validate.FormatOf("supersededAt", "body", "date-time", m.SupersededAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SherlockChangesetV3) validateToResolvedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.ToResolvedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("toResolvedAt", "body", "date-time", m.ToResolvedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *SherlockChangesetV3) validateUpdatedAt(formats strfmt.Registry) error {
	if swag.IsZero(m.UpdatedAt) { // not required
		return nil
	}

	if err := validate.FormatOf("updatedAt", "body", "date-time", m.UpdatedAt.String(), formats); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this sherlock changeset v3 based on the context it is used
func (m *SherlockChangesetV3) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAppliedByInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateChartReleaseInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCiIdentifier(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNewAppVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNewChartVersions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePlannedByInfo(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *SherlockChangesetV3) contextValidateAppliedByInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.AppliedByInfo != nil {
		if err := m.AppliedByInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("appliedByInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("appliedByInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) contextValidateChartReleaseInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.ChartReleaseInfo != nil {
		if err := m.ChartReleaseInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("chartReleaseInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("chartReleaseInfo")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) contextValidateCiIdentifier(ctx context.Context, formats strfmt.Registry) error {

	if m.CiIdentifier != nil {
		if err := m.CiIdentifier.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ciIdentifier")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ciIdentifier")
			}
			return err
		}
	}

	return nil
}

func (m *SherlockChangesetV3) contextValidateNewAppVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NewAppVersions); i++ {

		if m.NewAppVersions[i] != nil {
			if err := m.NewAppVersions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("newAppVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("newAppVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SherlockChangesetV3) contextValidateNewChartVersions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.NewChartVersions); i++ {

		if m.NewChartVersions[i] != nil {
			if err := m.NewChartVersions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("newChartVersions" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("newChartVersions" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *SherlockChangesetV3) contextValidatePlannedByInfo(ctx context.Context, formats strfmt.Registry) error {

	if m.PlannedByInfo != nil {
		if err := m.PlannedByInfo.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("plannedByInfo")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("plannedByInfo")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *SherlockChangesetV3) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *SherlockChangesetV3) UnmarshalBinary(b []byte) error {
	var res SherlockChangesetV3
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
