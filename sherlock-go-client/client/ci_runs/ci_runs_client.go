// Code generated by go-swagger; DO NOT EDIT.

package ci_runs

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"fmt"

	"github.com/go-openapi/runtime"
	"github.com/go-openapi/strfmt"
)

// New creates a new ci runs API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
	return &Client{transport: transport, formats: formats}
}

/*
Client for ci runs API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

// ClientOption is the option for Client methods
type ClientOption func(*runtime.ClientOperation)

// ClientService is the interface for Client methods
type ClientService interface {
	GetAPICiRunsProceduresV3GithubInfo(params *GetAPICiRunsProceduresV3GithubInfoParams, opts ...ClientOption) (*GetAPICiRunsProceduresV3GithubInfoOK, error)

	GetAPICiRunsV3(params *GetAPICiRunsV3Params, opts ...ClientOption) (*GetAPICiRunsV3OK, error)

	GetAPICiRunsV3Selector(params *GetAPICiRunsV3SelectorParams, opts ...ClientOption) (*GetAPICiRunsV3SelectorOK, error)

	PutAPICiRunsV3(params *PutAPICiRunsV3Params, opts ...ClientOption) (*PutAPICiRunsV3Created, error)

	SetTransport(transport runtime.ClientTransport)
}

/*
  GetAPICiRunsProceduresV3GithubInfo lists git hub info gleaned from ci runs

  List info about GitHub repos and their workflow files as determined by CiRuns from the past 90 days.
This is a useful proxy for figuring out what repos Sherlock probably has access to: workflows listed
here can probably successfully called by a GitHub Actions deploy hook.
*/
func (a *Client) GetAPICiRunsProceduresV3GithubInfo(params *GetAPICiRunsProceduresV3GithubInfoParams, opts ...ClientOption) (*GetAPICiRunsProceduresV3GithubInfoOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAPICiRunsProceduresV3GithubInfoParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAPICiRunsProceduresV3GithubInfo",
		Method:             "GET",
		PathPattern:        "/api/ci-runs/procedures/v3/github-info",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAPICiRunsProceduresV3GithubInfoReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAPICiRunsProceduresV3GithubInfoOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAPICiRunsProceduresV3GithubInfo: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAPICiRunsV3 lists ci runs matching a filter

  List CiRuns matching a filter. The CiRuns would have to re-queried directly to load any related resources.
Results are ordered by start time, starting at most recent.
*/
func (a *Client) GetAPICiRunsV3(params *GetAPICiRunsV3Params, opts ...ClientOption) (*GetAPICiRunsV3OK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAPICiRunsV3Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAPICiRunsV3",
		Method:             "GET",
		PathPattern:        "/api/ci-runs/v3",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAPICiRunsV3Reader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAPICiRunsV3OK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAPICiRunsV3: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  GetAPICiRunsV3Selector gets a ci run including ci identifiers for related resources

  Get a CiRun, including CiIdentifiers representing related resources or resources it affected.
*/
func (a *Client) GetAPICiRunsV3Selector(params *GetAPICiRunsV3SelectorParams, opts ...ClientOption) (*GetAPICiRunsV3SelectorOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetAPICiRunsV3SelectorParams()
	}
	op := &runtime.ClientOperation{
		ID:                 "GetAPICiRunsV3Selector",
		Method:             "GET",
		PathPattern:        "/api/ci-runs/v3/{selector}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetAPICiRunsV3SelectorReader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*GetAPICiRunsV3SelectorOK)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for GetAPICiRunsV3Selector: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

/*
  PutAPICiRunsV3 creates or update a ci run

  Create or update a CiRun with timing, status, and related resource information. This endpoint is idempotent.
The fields for clusters, charts, chart releases, environments, etc. all accept selectors, and they will
be smart about "spreading" to indirect relations. More info is available on the CiRunV3Upsert data type,
but the gist is that specifying a changeset implies its chart release (and optionally app/chart versions),
specifying or implying a chart release implies its environment/cluster, and specifying an environment/cluster
implies all chart releases they contain.
*/
func (a *Client) PutAPICiRunsV3(params *PutAPICiRunsV3Params, opts ...ClientOption) (*PutAPICiRunsV3Created, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPutAPICiRunsV3Params()
	}
	op := &runtime.ClientOperation{
		ID:                 "PutAPICiRunsV3",
		Method:             "PUT",
		PathPattern:        "/api/ci-runs/v3",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PutAPICiRunsV3Reader{formats: a.formats},
		Context:            params.Context,
		Client:             params.HTTPClient,
	}
	for _, opt := range opts {
		opt(op)
	}

	result, err := a.transport.Submit(op)
	if err != nil {
		return nil, err
	}
	success, ok := result.(*PutAPICiRunsV3Created)
	if ok {
		return success, nil
	}
	// unexpected success response
	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
	msg := fmt.Sprintf("unexpected success response for PutAPICiRunsV3: API contract not enforced by server. Client expected to get an error, but got: %T", result)
	panic(msg)
}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
